{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///Users/apple/Desktop/GOSSIP/src/lib/supabase/client.ts"],"sourcesContent":["import { createBrowserClient } from '@supabase/ssr'\nimport { SupabaseClient } from '@supabase/supabase-js'\n\nlet clientInstance: SupabaseClient | null = null;\n\nexport function createClient() {\n    if (!clientInstance) {\n        clientInstance = createBrowserClient(\n            process.env.NEXT_PUBLIC_SUPABASE_URL!,\n            process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n        )\n    }\n    return clientInstance;\n}\n\nexport const safeSupabaseOperation = async <T>(\n    operation: (client: SupabaseClient) => Promise<T>\n): Promise<T> => {\n    const client = createClient();\n    return await operation(client);\n};\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;;AAGA,IAAI,iBAAwC;AAErC,SAAS;IACZ,IAAI,CAAC,gBAAgB;QACjB,iBAAiB,IAAA,sNAAmB;IAIxC;IACA,OAAO;AACX;AAEO,MAAM,wBAAwB,OACjC;IAEA,MAAM,SAAS;IACf,OAAO,MAAM,UAAU;AAC3B"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///Users/apple/Desktop/GOSSIP/src/contexts/auth-context.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { createClient } from '@/lib/supabase/client';\nimport { User } from '@supabase/supabase-js';\n\nexport interface AuthUser {\n    id: string;\n    email: string;\n    username: string;\n    full_name?: string;\n    avatar_url?: string;\n    age?: number;\n    phone?: string;\n    bio?: string;\n    gender?: string;\n    created_at: string;\n    updated_at: string;\n}\n\ninterface AuthContextType {\n    user: AuthUser | null;\n    loading: boolean;\n    operationLoading: boolean;\n    signInWithPassword: (email: string, pass: string) => Promise<{ error?: string }>;\n    signUpWithPassword: (email: string, pass: string, metadata: any) => Promise<{ error?: string; needsEmailConfirmation?: boolean }>;\n    logout: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n    const [user, setUser] = useState<AuthUser | null>(null);\n    const [loading, setLoading] = useState(true);\n    const [operationLoading, setOperationLoading] = useState(false);\n    const supabase = createClient();\n\n    const mapUser = (supabaseUser: User, profile?: any): AuthUser => ({\n        id: supabaseUser.id,\n        email: supabaseUser.email || '',\n        username: profile?.username || supabaseUser.user_metadata?.username || supabaseUser.email?.split('@')[0],\n        full_name: profile?.full_name || supabaseUser.user_metadata?.full_name,\n        avatar_url: profile?.avatar_url || supabaseUser.user_metadata?.avatar_url,\n        age: profile?.age,\n        phone: profile?.phone,\n        bio: profile?.bio,\n        gender: profile?.gender,\n        created_at: supabaseUser.created_at,\n        updated_at: supabaseUser.updated_at || supabaseUser.created_at,\n    });\n\n    const fetchUser = async (supabaseUser: User) => {\n        const { data: profile } = await supabase\n            .from('profiles')\n            .select('*')\n            .eq('id', supabaseUser.id)\n            .single();\n\n        setUser(mapUser(supabaseUser, profile));\n    };\n\n    useEffect(() => {\n        const initialize = async () => {\n            const { data: { session } } = await supabase.auth.getSession();\n            if (session?.user) {\n                await fetchUser(session.user);\n            }\n            setLoading(false);\n\n            const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, session) => {\n                if (session?.user) {\n                    await fetchUser(session.user);\n                } else {\n                    setUser(null);\n                }\n                setLoading(false);\n            });\n\n            return () => subscription.unsubscribe();\n        };\n\n        initialize();\n    }, []);\n\n    const signInWithPassword = async (email: string, pass: string) => {\n        setOperationLoading(true);\n        const { error } = await supabase.auth.signInWithPassword({ email, password: pass });\n        setOperationLoading(false);\n        return { error: error?.message };\n    };\n\n    const signUpWithPassword = async (email: string, pass: string, metadata: any) => {\n        setOperationLoading(true);\n        const { data, error } = await supabase.auth.signUp({\n            email,\n            password: pass,\n            options: { data: metadata }\n        });\n        setOperationLoading(false);\n        return {\n            error: error?.message,\n            needsEmailConfirmation: !!(data.user && !data.session)\n        };\n    };\n\n    const logout = async () => {\n        await supabase.auth.signOut();\n        setUser(null);\n    };\n\n    return (\n        <AuthContext.Provider value={{\n            user,\n            loading,\n            operationLoading,\n            signInWithPassword,\n            signUpWithPassword,\n            logout\n        }}>\n            {children}\n        </AuthContext.Provider>\n    );\n}\n\nexport const useAuth = () => {\n    const context = useContext(AuthContext);\n    if (!context) throw new Error('useAuth must be used within AuthProvider');\n    return context;\n};\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AAHA;;;;AA6BA,MAAM,4BAAc,IAAA,2OAAa,EAA8B;AAExD,SAAS,aAAa,EAAE,QAAQ,EAA2B;IAC9D,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,sOAAQ,EAAkB;IAClD,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,sOAAQ,EAAC;IACvC,MAAM,CAAC,kBAAkB,oBAAoB,GAAG,IAAA,sOAAQ,EAAC;IACzD,MAAM,WAAW,IAAA,qKAAY;IAE7B,MAAM,UAAU,CAAC,cAAoB,UAA4B,CAAC;YAC9D,IAAI,aAAa,EAAE;YACnB,OAAO,aAAa,KAAK,IAAI;YAC7B,UAAU,SAAS,YAAY,aAAa,aAAa,EAAE,YAAY,aAAa,KAAK,EAAE,MAAM,IAAI,CAAC,EAAE;YACxG,WAAW,SAAS,aAAa,aAAa,aAAa,EAAE;YAC7D,YAAY,SAAS,cAAc,aAAa,aAAa,EAAE;YAC/D,KAAK,SAAS;YACd,OAAO,SAAS;YAChB,KAAK,SAAS;YACd,QAAQ,SAAS;YACjB,YAAY,aAAa,UAAU;YACnC,YAAY,aAAa,UAAU,IAAI,aAAa,UAAU;QAClE,CAAC;IAED,MAAM,YAAY,OAAO;QACrB,MAAM,EAAE,MAAM,OAAO,EAAE,GAAG,MAAM,SAC3B,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM,aAAa,EAAE,EACxB,MAAM;QAEX,QAAQ,QAAQ,cAAc;IAClC;IAEA,IAAA,uOAAS,EAAC;QACN,MAAM,aAAa;YACf,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,UAAU;YAC5D,IAAI,SAAS,MAAM;gBACf,MAAM,UAAU,QAAQ,IAAI;YAChC;YACA,WAAW;YAEX,MAAM,EAAE,MAAM,EAAE,YAAY,EAAE,EAAE,GAAG,SAAS,IAAI,CAAC,iBAAiB,CAAC,OAAO,OAAO;gBAC7E,IAAI,SAAS,MAAM;oBACf,MAAM,UAAU,QAAQ,IAAI;gBAChC,OAAO;oBACH,QAAQ;gBACZ;gBACA,WAAW;YACf;YAEA,OAAO,IAAM,aAAa,WAAW;QACzC;QAEA;IACJ,GAAG,EAAE;IAEL,MAAM,qBAAqB,OAAO,OAAe;QAC7C,oBAAoB;QACpB,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,kBAAkB,CAAC;YAAE;YAAO,UAAU;QAAK;QACjF,oBAAoB;QACpB,OAAO;YAAE,OAAO,OAAO;QAAQ;IACnC;IAEA,MAAM,qBAAqB,OAAO,OAAe,MAAc;QAC3D,oBAAoB;QACpB,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,MAAM,CAAC;YAC/C;YACA,UAAU;YACV,SAAS;gBAAE,MAAM;YAAS;QAC9B;QACA,oBAAoB;QACpB,OAAO;YACH,OAAO,OAAO;YACd,wBAAwB,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,OAAO;QACzD;IACJ;IAEA,MAAM,SAAS;QACX,MAAM,SAAS,IAAI,CAAC,OAAO;QAC3B,QAAQ;IACZ;IAEA,qBACI,mQAAC,YAAY,QAAQ;QAAC,OAAO;YACzB;YACA;YACA;YACA;YACA;YACA;QACJ;kBACK;;;;;;AAGb;AAEO,MAAM,UAAU;IACnB,MAAM,UAAU,IAAA,wOAAU,EAAC;IAC3B,IAAI,CAAC,SAAS,MAAM,IAAI,MAAM;IAC9B,OAAO;AACX"}},
    {"offset": {"line": 144, "column": 0}, "map": {"version":3,"sources":["file:///Users/apple/Desktop/GOSSIP/src/services/notification-service.ts"],"sourcesContent":["export const sendPushNotification = async (token: string, title: string, body: string, data?: any) => {\n    console.log('[NotificationService] Web Push Stub:', { token, title, body, data });\n    // In a real web app, you'd use the Web Push API or a service like Firebase Cloud Messaging for Web\n    return true;\n};\n\nexport const registerForPushNotificationsAsync = async () => {\n    console.log('[NotificationService] Register for Push Stub');\n    return null;\n};\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,uBAAuB,OAAO,OAAe,OAAe,MAAc;IACnF,QAAQ,GAAG,CAAC,wCAAwC;QAAE;QAAO;QAAO;QAAM;IAAK;IAC/E,mGAAmG;IACnG,OAAO;AACX;AAEO,MAAM,oCAAoC;IAC7C,QAAQ,GAAG,CAAC;IACZ,OAAO;AACX"}},
    {"offset": {"line": 168, "column": 0}, "map": {"version":3,"sources":["file:///Users/apple/Desktop/GOSSIP/src/services/chat-service.ts"],"sourcesContent":["import { safeSupabaseOperation } from '@/lib/supabase/client';\nimport { sendPushNotification } from '@/services/notification-service';\n\nexport interface Room {\n    id: string;\n    name: string | null;\n    description: string | null;\n    type: 'direct' | 'group';\n    created_by: string;\n    created_at: string;\n    avatar_url: string | null;\n}\n\nexport interface MessageData {\n    id: string;\n    room_id: string;\n    user_id: string;\n    content: string;\n    message_type: 'text' | 'image' | 'video' | 'audio' | 'document';\n    media_url?: string;\n    status: 'sent' | 'delivered' | 'read';\n    created_at: string;\n}\n\nexport const ChatService = {\n    async getMyRooms(): Promise<{ data: any[]; error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                const { data: { user } } = await client.auth.getUser();\n                if (!user) throw new Error('Not authenticated');\n\n                const { data, error } = await client\n                    .from('room_participants')\n                    .select(`\n            room_id,\n            rooms (*)\n          `)\n                    .eq('user_id', user.id);\n\n                if (error) return { data: [], error: error.message };\n                if (!data || data.length === 0) return { data: [], error: null };\n\n                // Get blocked users to filter them out\n                const { data: blockedData } = await client\n                    .from('blocked_users')\n                    .select('blocked_id')\n                    .eq('blocker_id', user.id);\n                const blockedIds = (blockedData || []).map((b: any) => b.blocked_id);\n\n                // Get rooms and filter out those with blocked participants (for direct chats)\n                const filteredRooms = [];\n                for (const item of data) {\n                    const room = item.rooms as any;\n                    if (!room) continue;\n\n                    if (room.type === 'direct') {\n                        // For direct chats, we need to check if the other person is blocked\n                        const { data: participants } = await client\n                            .from('room_participants')\n                            .select('user_id')\n                            .eq('room_id', room.id)\n                            .neq('user_id', user.id);\n\n                        const otherUserId = participants?.[0]?.user_id;\n                        if (otherUserId && blockedIds.includes(otherUserId)) {\n                            continue; // Skip this room\n                        }\n                    }\n                    filteredRooms.push(room);\n                }\n\n                return { data: filteredRooms, error: null };\n            });\n        } catch (err: any) {\n            return { data: [], error: err.message };\n        }\n    },\n\n    async getRoomParticipants(roomId: string): Promise<{ data: any[]; error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                const { data, error } = await client\n                    .from('room_participants')\n                    .select(`\n            user_id,\n            profiles (\n              id,\n              username,\n              full_name,\n              avatar_url,\n              is_online,\n              last_seen,\n              gender,\n              age\n            )\n          `)\n                    .eq('room_id', roomId);\n\n                if (error) return { data: [], error: error.message };\n                return { data: data.map((p: any) => p.profiles), error: null };\n            });\n        } catch (err: any) {\n            return { data: [], error: err.message };\n        }\n    },\n\n    async getMessages(roomId: string, limit = 50, ascending = true): Promise<{ data: MessageData[]; error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                const { data, error } = await client\n                    .from('messages')\n                    .select('*')\n                    .eq('room_id', roomId)\n                    .order('created_at', { ascending })\n                    .limit(limit);\n\n                if (error) return { data: [], error: error.message };\n                return { data: (data as MessageData[]) || [], error: null };\n            });\n        } catch (err: any) {\n            return { data: [], error: err.message };\n        }\n    },\n\n    async sendMessage(roomId: string, content: string, type: string = 'text', mediaUrl?: string): Promise<{ data: MessageData | null; error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                const { data: { user } } = await client.auth.getUser();\n                if (!user) throw new Error('Not authenticated');\n\n                // Check if anyone in the room has blocked the sender\n                const { data: participants } = await client\n                    .from('room_participants')\n                    .select('user_id')\n                    .eq('room_id', roomId)\n                    .neq('user_id', user.id);\n\n                if (participants && participants.length > 0) {\n                    const participantIds = participants.map(p => p.user_id);\n                    const { data: blocks } = await client\n                        .from('blocked_users')\n                        .select('id')\n                        .or(`and(blocker_id.eq.${user.id},blocked_id.in.(${participantIds.join(',')})),and(blocker_id.in.(${participantIds.join(',')}),blocked_id.eq.${user.id})`)\n                        .maybeSingle();\n\n                    if (blocks) {\n                        throw new Error('Cannot send message: Blocked connection');\n                    }\n                }\n\n                const { data, error } = await client\n                    .from('messages')\n                    .insert({\n                        room_id: roomId,\n                        user_id: user.id,\n                        content,\n                        message_type: type,\n                        media_url: mediaUrl,\n                        status: 'sent'\n                    })\n                    .select()\n                    .single();\n\n                if (error) {\n                    console.error('[ChatService] sendMessage error:', error);\n                    return { data: null, error: error.message };\n                }\n\n                // Send Push Notifications asynchronously\n                (async () => {\n                    try {\n                        // Get all participants except sender\n                        const { data: recipients } = await client\n                            .from('room_participants')\n                            .select('user_id, profiles(push_token, full_name, username)')\n                            .eq('room_id', roomId)\n                            .neq('user_id', user.id);\n\n                        if (recipients) {\n                            const senderName = user.user_metadata?.username || 'Gossiper';\n                            const title = `New Gossip from ${senderName}`;\n                            const body = type === 'text' ? content : `Sent a ${type}`;\n\n                            for (const r of recipients) {\n                                const profile = r.profiles as any;\n                                if (profile && profile.push_token) {\n                                    sendPushNotification(profile.push_token, title, body, {\n                                        chatId: roomId,\n                                        senderId: user.id\n                                    });\n                                }\n                            }\n                        }\n                    } catch (pushErr) {\n                        console.error('[ChatService] Failed to send push:', pushErr);\n                    }\n                })();\n\n                return { data: data as MessageData, error: null };\n            });\n        } catch (err: any) {\n            return { data: null, error: err.message };\n        }\n    },\n\n    async createDirectChat(otherUserId: string): Promise<{ data: string | null; error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                const { data: { user } } = await client.auth.getUser();\n                if (!user) throw new Error('Not authenticated');\n\n                const { data: existing } = await client.rpc('get_direct_room', {\n                    user1: user.id,\n                    user2: otherUserId\n                });\n\n                if (existing) return { data: existing, error: null };\n\n                const { data: room, error: roomError } = await client\n                    .from('rooms')\n                    .insert({ type: 'direct', created_by: user.id })\n                    .select()\n                    .single();\n\n                if (roomError) return { data: null, error: roomError.message };\n\n                const participants = [\n                    { room_id: room.id, user_id: user.id, role: 'owner' },\n                    { room_id: room.id, user_id: otherUserId, role: 'member' }\n                ];\n\n                const { error: partError } = await client\n                    .from('room_participants')\n                    .insert(participants);\n\n                if (partError) return { data: null, error: partError.message };\n\n                return { data: room.id, error: null };\n            });\n        } catch (err: any) {\n            return { data: null, error: err.message };\n        }\n    },\n\n    async createGroupChat(name: string, participantIds: string[]): Promise<{ data: string | null; error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                const { data: { user } } = await client.auth.getUser();\n                if (!user) throw new Error('Not authenticated');\n\n                const { data: room, error: roomError } = await client\n                    .from('rooms')\n                    .insert({ name, type: 'group', created_by: user.id })\n                    .select()\n                    .single();\n\n                if (roomError) return { data: null, error: roomError.message };\n\n                const participants = [\n                    { room_id: room.id, user_id: user.id, role: 'owner' },\n                    ...participantIds.map(id => ({ room_id: room.id, user_id: id, role: 'member' }))\n                ];\n\n                const { error: partError } = await client\n                    .from('room_participants')\n                    .insert(participants);\n\n                if (partError) return { data: null, error: partError.message };\n\n                return { data: room.id, error: null };\n            });\n        } catch (err: any) {\n            return { data: null, error: err.message };\n        }\n    },\n\n    async updateRoom(roomId: string, updates: { name?: string; description?: string; avatar_url?: string }): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { error } = await client\n                .from('rooms')\n                .update(updates)\n                .eq('id', roomId);\n            return { error: error?.message || null };\n        });\n    },\n\n    async uploadGroupAvatar(roomId: string, file: File): Promise<{ data: string | null; error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            try {\n                const fileExt = file.name.split('.').pop() || 'jpg';\n                const fileName = `group_${roomId}_${Date.now()}.${fileExt}`;\n                const filePath = `groups/${fileName}`;\n\n                const { error: uploadError } = await client.storage\n                    .from('gossip-avatars')\n                    .upload(filePath, file, {\n                        contentType: file.type,\n                        upsert: false\n                    });\n\n                if (uploadError) throw uploadError;\n\n                const { data } = client.storage\n                    .from('gossip-avatars')\n                    .getPublicUrl(filePath);\n\n                return { data: data.publicUrl, error: null };\n            } catch (err: any) {\n                return { data: null, error: err.message };\n            }\n        });\n    },\n\n    async uploadChatAttachment(roomId: string, file: File, type: 'image' | 'video' | 'audio' | 'document'): Promise<{ data: string | null; error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            try {\n                const fileExt = file.name.split('.').pop() || 'dat';\n                const folder = type === 'image' ? 'images' : type === 'video' ? 'videos' : 'docs';\n                const fileName = `${folder}/${roomId}_${Date.now()}.${fileExt}`;\n\n                const { error: uploadError } = await client.storage\n                    .from('chat-attachments')\n                    .upload(fileName, file, {\n                        contentType: file.type,\n                        upsert: false\n                    });\n\n                if (uploadError) throw uploadError;\n\n                const { data } = client.storage\n                    .from('chat-attachments')\n                    .getPublicUrl(fileName);\n\n                return { data: data.publicUrl, error: null };\n            } catch (err: any) {\n                return { data: null, error: err.message };\n            }\n        });\n    },\n\n    async updateOnlineStatus(userId: string, isOnline: boolean): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { error } = await client\n                .from('profiles')\n                .update({ is_online: isOnline, last_seen: new Date().toISOString() })\n                .eq('id', userId);\n            return { error: error?.message || null };\n        });\n    },\n\n    async getRoomParticipantsProfiles(roomId: string): Promise<{ data: any[]; error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { data, error } = await client\n                .from('room_participants')\n                .select('profiles (*)')\n                .eq('room_id', roomId);\n            if (error) return { data: [], error: error.message };\n            return { data: data.map((p: any) => p.profiles), error: null };\n        });\n    },\n\n    async sendConnectionRequest(targetUserId: string): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { error: 'Not authenticated' };\n\n            const { error } = await client\n                .from('connections')\n                .insert({\n                    requester_id: user.id,\n                    addressee_id: targetUserId,\n                    status: 'pending'\n                });\n\n            return { error: error?.message || null };\n        });\n    },\n\n    async getPendingRequests(): Promise<{ data: any[]; error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { data: [], error: 'Not authenticated' };\n\n            const { data, error } = await client\n                .from('connections')\n                .select(`\n                    id,\n                    requester_id,\n                    created_at,\n                    profiles:requester_id (\n                        id,\n                        username,\n                        full_name,\n                        avatar_url\n                    )\n                `)\n                .eq('addressee_id', user.id)\n                .eq('status', 'pending');\n\n            if (error) return { data: [], error: error.message };\n            return { data: data || [], error: null };\n        });\n    },\n\n    async getAcceptedConnections(): Promise<{ data: any[]; error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { data: [], error: 'Not authenticated' };\n\n            // Get connections where I am requester OR addressee\n            const { data, error } = await client\n                .from('connections')\n                .select(`\n                    id,\n                    requester_id,\n                    addressee_id,\n                    status,\n                    created_at,\n                    requester:requester_id (id, username, full_name, avatar_url, is_online, last_seen, gender, age),\n                    addressee:addressee_id (id, username, full_name, avatar_url, is_online, last_seen, gender, age)\n                `)\n                .or(`requester_id.eq.${user.id},addressee_id.eq.${user.id}`)\n                .eq('status', 'accepted');\n\n            if (error) return { data: [], error: error.message };\n\n            // Transform to just return the OTHER user's profile\n            const connections = data.map((conn: any) => {\n                const isRequester = conn.requester_id === user.id;\n                const profile = isRequester ? conn.addressee : conn.requester;\n                return {\n                    connection_id: conn.id,\n                    ...profile\n                };\n            });\n\n            return { data: connections, error: null };\n        });\n    },\n\n    async respondToConnection(connectionId: string, status: 'accepted' | 'rejected'): Promise<{ data: string | null; error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { error } = await client\n                .from('connections')\n                .update({ status })\n                .eq('id', connectionId);\n\n            if (error) return { data: null, error: error.message };\n\n            let roomId = null;\n            // If accepted, create a direct chat room\n            if (status === 'accepted') {\n                const { data: connection } = await client\n                    .from('connections')\n                    .select('requester_id, addressee_id')\n                    .eq('id', connectionId)\n                    .single();\n\n                if (connection) {\n                    const { data: id, error: chatError } = await this.createDirectChat(connection.requester_id);\n                    if (chatError) return { data: null, error: chatError };\n                    roomId = id;\n                }\n            }\n\n            return { data: roomId, error: null };\n        });\n    },\n\n    async deleteRoom(roomId: string): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { error } = await client.from('rooms').delete().eq('id', roomId);\n            return { error: error?.message || null };\n        });\n    },\n\n    async updateMessageStatus(messageId: string, status: 'delivered' | 'read'): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const updateObj: any = { status };\n            if (status === 'delivered') updateObj.delivered_at = new Date().toISOString();\n            if (status === 'read') updateObj.read_at = new Date().toISOString();\n\n            const { error } = await client\n                .from('messages')\n                .update(updateObj)\n                .eq('id', messageId);\n            return { error: error?.message || null };\n        });\n    },\n\n    async markRoomAsRead(roomId: string, userId: string): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { error } = await client\n                .from('messages')\n                .update({ status: 'read', read_at: new Date().toISOString() })\n                .eq('room_id', roomId)\n                .neq('user_id', userId)\n                .neq('status', 'read');\n            return { error: error?.message || null };\n        });\n    },\n\n    async blockUser(targetUserId: string): Promise<{ error: string | null }> {\n        console.log('[ChatService] Blocking user:', targetUserId);\n        return await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { error: 'Not authenticated' };\n\n            const { error } = await client\n                .from('blocked_users')\n                .insert({ blocker_id: user.id, blocked_id: targetUserId });\n\n            if (error) {\n                console.error('[ChatService] blockUser error:', error);\n                return { error: error.message };\n            }\n            return { error: null };\n        });\n    },\n\n    async unblockUser(targetUserId: string): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { error: 'Not authenticated' };\n\n            const { error } = await client\n                .from('blocked_users')\n                .delete()\n                .eq('blocker_id', user.id)\n                .eq('blocked_id', targetUserId);\n            return { error: error?.message || null };\n        });\n    },\n\n    async isBlocked(targetUserId: string): Promise<boolean> {\n        const { data } = await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { data: null };\n\n            return await client\n                .from('blocked_users')\n                .select('id')\n                .or(`and(blocker_id.eq.${user.id},blocked_id.eq.${targetUserId}),and(blocker_id.eq.${targetUserId},blocked_id.eq.${user.id})`)\n                .maybeSingle();\n        });\n        return !!data;\n    },\n\n    async getBlockedUsers(): Promise<{ data: any[]; error: string | null }> {\n        console.log('[ChatService] Fetching blocked users...');\n        return await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { data: [], error: 'Not authenticated' };\n\n            const { data, error } = await client\n                .from('blocked_users')\n                .select(`\n                    id,\n                    blocked_id,\n                    profiles:blocked_id (*)\n                `)\n                .eq('blocker_id', user.id);\n\n            if (error) {\n                console.error('[ChatService] getBlockedUsers error:', error);\n                return { data: [], error: error.message };\n            }\n\n            const blockedUsers = (data || []).map((item: any) => ({\n                id: item.blocked_id,\n                username: item.profiles?.username || 'Unknown',\n                full_name: item.profiles?.full_name || 'Unknown Gossiper',\n                avatar_url: item.profiles?.avatar_url\n            }));\n\n            console.log(`[ChatService] Found ${blockedUsers.length} blocked users`);\n            return { data: blockedUsers, error: null };\n        });\n    }\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 737, "column": 0}, "map": {"version":3,"sources":["file:///Users/apple/Desktop/GOSSIP/src/contexts/chat-context.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { createContext, useState, ReactNode, useEffect, useRef, useContext } from 'react';\nimport { useAuth } from './auth-context';\nimport { createClient } from '@/lib/supabase/client';\nimport { ChatService, MessageData } from '@/services/chat-service';\n\nexport interface Message {\n    id: string;\n    chatId: string;\n    senderId: string;\n    content: string;\n    type: 'text' | 'image' | 'video' | 'audio' | 'document';\n    timestamp: Date;\n    status: 'sent' | 'delivered' | 'read';\n    mediaUrl?: string;\n}\n\nexport interface Chat {\n    id: string;\n    userId: string;\n    userName: string;\n    userAvatar: string;\n    lastMessage: string;\n    lastMessageTime: Date;\n    unreadCount: number;\n    online: boolean;\n    typing: boolean;\n    type: 'direct' | 'group';\n    age?: number;\n    gender?: string;\n    onlineCount?: number;\n    memberCount?: number;\n    description?: string;\n    createdBy?: string;\n}\n\nexport interface ConnectionRequest {\n    id: string;\n    requester_id: string;\n    created_at: string;\n    profiles: {\n        id: string;\n        username: string;\n        full_name: string;\n        avatar_url: string;\n    };\n}\n\ninterface ChatContextType {\n    chats: Chat[];\n    messages: Record<string, Message[]>;\n    pendingRequests: ConnectionRequest[];\n    loading: boolean;\n    sendMessage: (chatId: string, content: string, type?: string, mediaUrl?: string) => Promise<void>;\n    markAsRead: (chatId: string) => void;\n    setTyping: (chatId: string, isTyping: boolean) => void;\n    createChat: (userId: string, userName: string, userAvatar: string) => Promise<string>;\n    sendRequest: (userId: string) => Promise<void>;\n    respondToRequest: (requestId: string, status: 'accepted' | 'rejected') => Promise<string | null>;\n    refreshChats: () => Promise<void>;\n    blockUser: (userId: string) => Promise<void>;\n    unblockUser: (userId: string) => Promise<void>;\n    deleteGroup: (roomId: string) => Promise<void>;\n    fetchMessages: (chatId: string) => Promise<void>;\n    updateGroup: (roomId: string, updates: { name?: string; description?: string; avatar_url?: string }) => Promise<void>;\n    getParticipants: (roomId: string) => Promise<any[]>;\n    lockedChats: Record<string, string>; // Map chatId -> PIN\n    lockChat: (chatId: string, pin: string) => Promise<void>;\n    unlockChat: (chatId: string) => Promise<void>;\n}\n\nexport const ChatContext = createContext<ChatContextType | undefined>(undefined);\n\nexport function ChatProvider({ children }: { children: ReactNode }) {\n    const { user } = useAuth();\n    const [chats, setChats] = useState<Chat[]>([]);\n    const [messages, setMessages] = useState<Record<string, Message[]>>({});\n    const [pendingRequests, setPendingRequests] = useState<ConnectionRequest[]>([]);\n    const [lockedChats, setLockedChats] = useState<Record<string, string>>({});\n    const [loading, setLoading] = useState(false);\n    const supabase = createClient();\n    const channelRef = useRef<any>(null);\n    const isFetchingRef = useRef(false);\n    const hasInitialLoaded = useRef(false);\n\n    useEffect(() => {\n        if (user?.id) {\n            if (!hasInitialLoaded.current) {\n                setLoading(true);\n                loadInitialData().finally(() => {\n                    setLoading(false);\n                    hasInitialLoaded.current = true;\n                });\n            }\n\n            setupRealtime();\n            ChatService.updateOnlineStatus(user.id, true);\n\n            const pollInterval = setInterval(() => {\n                refreshChats();\n            }, 30000);\n\n            return () => {\n                clearInterval(pollInterval);\n                ChatService.updateOnlineStatus(user.id, false);\n                cleanupRealtime();\n            };\n        } else {\n            setChats([]);\n            setMessages({});\n            setPendingRequests([]);\n            setLockedChats({});\n            setLoading(false);\n            hasInitialLoaded.current = false;\n            cleanupRealtime();\n        }\n    }, [user?.id]);\n\n    useEffect(() => {\n        const stored = localStorage.getItem('LOCKED_CHATS');\n        if (stored) setLockedChats(JSON.parse(stored));\n    }, []);\n\n    const cleanupRealtime = () => {\n        if (channelRef.current) {\n            supabase.removeChannel(channelRef.current);\n            channelRef.current = null;\n        }\n    };\n\n    const loadInitialData = async () => {\n        if (isFetchingRef.current) return;\n        isFetchingRef.current = true;\n        try {\n            const [roomsResponse, requestsResponse, connectionsResponse] = await Promise.all([\n                ChatService.getMyRooms(),\n                ChatService.getPendingRequests(),\n                ChatService.getAcceptedConnections()\n            ]);\n\n            if (requestsResponse.data) {\n                setPendingRequests(requestsResponse.data);\n            }\n\n            const formattedChats: Chat[] = [];\n            const existingUserIds = new Set<string>();\n\n            if (roomsResponse.data) {\n                const chatPromises = roomsResponse.data.map(room => formatRoomToChat(room));\n                const results = await Promise.all(chatPromises);\n                results.forEach(chat => {\n                    if (chat) {\n                        formattedChats.push(chat);\n                        if (chat.type === 'direct') existingUserIds.add(chat.userId);\n                    }\n                });\n            }\n\n            if (connectionsResponse.data) {\n                connectionsResponse.data.forEach((conn: any) => {\n                    if (!existingUserIds.has(conn.id)) {\n                        formattedChats.push({\n                            id: `temp_${conn.id}`,\n                            userId: conn.id,\n                            userName: conn.username || conn.full_name || 'User',\n                            userAvatar: conn.avatar_url || `https://i.pravatar.cc/150?u=${conn.id}`,\n                            lastMessage: 'Tap to start chatting',\n                            lastMessageTime: new Date(conn.created_at || Date.now()),\n                            unreadCount: 0,\n                            online: conn.is_online || false,\n                            typing: false,\n                            type: 'direct',\n                            age: conn.age,\n                            gender: conn.gender,\n                        });\n                    }\n                });\n            }\n\n            setChats(prev => {\n                const sorted = [...formattedChats].sort((a, b) => b.lastMessageTime.getTime() - a.lastMessageTime.getTime());\n                if (JSON.stringify(prev) === JSON.stringify(sorted)) return prev;\n                return sorted;\n            });\n        } catch (error) {\n            console.error('[ChatContext] Load error:', error);\n        } finally {\n            isFetchingRef.current = false;\n        }\n    };\n\n    const formatRoomToChat = async (room: any): Promise<Chat | null> => {\n        const participants = await ChatService.getRoomParticipants(room.id);\n        const { data: msgs } = await ChatService.getMessages(room.id, 1, false);\n        const lastMsg = msgs?.[0];\n\n        if (room.type === 'direct') {\n            const otherUser = participants.data?.find(p => p.id !== user?.id);\n            if (otherUser) {\n                const { count } = await supabase\n                    .from('messages')\n                    .select('*', { count: 'exact', head: true })\n                    .eq('room_id', room.id)\n                    .neq('user_id', user?.id)\n                    .neq('status', 'read');\n\n                return {\n                    id: room.id,\n                    userId: otherUser.id,\n                    userName: otherUser.username || otherUser.full_name || 'User',\n                    userAvatar: otherUser.avatar_url || `https://i.pravatar.cc/150?u=${otherUser.id}`,\n                    lastMessage: lastMsg?.content || 'Started a gossip...',\n                    lastMessageTime: lastMsg ? new Date(lastMsg.created_at) : new Date(room.created_at),\n                    unreadCount: count || 0,\n                    online: otherUser.is_online || false,\n                    typing: false,\n                    type: 'direct',\n                    age: otherUser.age,\n                    gender: otherUser.gender,\n                };\n            }\n        } else {\n            const { count } = await supabase\n                .from('messages')\n                .select('*', { count: 'exact', head: true })\n                .eq('room_id', room.id)\n                .neq('user_id', user?.id)\n                .neq('status', 'read');\n\n            const onlineCount = participants.data?.filter(p => p.is_online).length || 0;\n            const memberCount = participants.data?.length || 0;\n\n            return {\n                id: room.id,\n                userId: room.id,\n                userName: room.name || 'Gossip Group',\n                userAvatar: room.avatar_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(room.name || 'G')}&background=FFB6C1&color=000`,\n                lastMessage: lastMsg?.content || 'New gossip group created!',\n                lastMessageTime: lastMsg ? new Date(lastMsg.created_at) : new Date(room.created_at),\n                unreadCount: count || 0,\n                online: onlineCount > 0,\n                onlineCount,\n                memberCount,\n                description: room.description || 'Welcome to the gossip group!',\n                createdBy: room.created_by,\n                typing: false,\n                type: 'group',\n            };\n        }\n        return null;\n    };\n\n    const setupRealtime = () => {\n        cleanupRealtime();\n        if (!user?.id) return;\n\n        const channel = supabase\n            .channel('gossip-main', {\n                config: {\n                    broadcast: { self: false },\n                    presence: { key: user.id }\n                }\n            })\n            .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, async (payload) => {\n                const newMessage = payload.new as MessageData;\n\n                if (newMessage.user_id !== user?.id && newMessage.status === 'sent') {\n                    ChatService.updateMessageStatus(newMessage.id, 'delivered');\n                }\n\n                const formattedMsg: Message = {\n                    id: newMessage.id,\n                    chatId: newMessage.room_id,\n                    senderId: newMessage.user_id,\n                    content: newMessage.content,\n                    type: newMessage.message_type as any,\n                    timestamp: new Date(newMessage.created_at),\n                    status: newMessage.status,\n                    mediaUrl: newMessage.media_url,\n                };\n\n                setMessages(prev => {\n                    const currentMsgs = prev[newMessage.room_id] || [];\n                    if (currentMsgs.some(m => m.id === formattedMsg.id)) return prev;\n                    return { ...prev, [newMessage.room_id]: [...currentMsgs, formattedMsg] };\n                });\n\n                refreshChats();\n            })\n            .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'messages' }, (payload) => {\n                const updatedMsg = payload.new as MessageData;\n                setMessages(prev => {\n                    const roomMsgs = prev[updatedMsg.room_id] || [];\n                    return {\n                        ...prev,\n                        [updatedMsg.room_id]: roomMsgs.map(m => m.id === updatedMsg.id ? { ...m, status: updatedMsg.status } : m)\n                    };\n                });\n            })\n            .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'profiles' }, (payload) => {\n                const updatedProfile = payload.new;\n                setChats(prev => prev.map(chat => chat.userId === updatedProfile.id ? { ...chat, online: updatedProfile.is_online } : chat));\n            })\n            .on('postgres_changes', { event: '*', schema: 'public', table: 'connections', filter: `addressee_id=eq.${user.id}` }, async () => {\n                const { data: requests } = await ChatService.getPendingRequests();\n                if (requests) setPendingRequests(requests);\n            })\n            .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'room_participants', filter: `user_id=eq.${user.id}` }, () => {\n                refreshChats();\n            })\n            .on('broadcast', { event: 'typing' }, (payload) => {\n                const { chatId, userId, isTyping } = payload.payload;\n                if (userId === user?.id) return;\n                setChats(prev => prev.map(chat => chat.id === chatId ? { ...chat, typing: isTyping } : chat));\n            })\n            .subscribe();\n\n        channelRef.current = channel;\n    };\n\n    const sendMessage = async (chatId: string, content: string, type: string = 'text', mediaUrl?: string) => {\n        const { data: sentMsg, error } = await ChatService.sendMessage(chatId, content, type, mediaUrl);\n        if (error) throw new Error(error);\n\n        if (sentMsg) {\n            const formattedMsg: Message = {\n                id: sentMsg.id,\n                chatId: sentMsg.room_id,\n                senderId: sentMsg.user_id,\n                content: sentMsg.content,\n                type: sentMsg.message_type as any,\n                timestamp: new Date(sentMsg.created_at),\n                status: sentMsg.status,\n                mediaUrl: sentMsg.media_url,\n            };\n\n            setMessages(prev => {\n                const currentMsgs = prev[chatId] || [];\n                if (currentMsgs.some(m => m.id === formattedMsg.id)) return prev;\n                return { ...prev, [chatId]: [...currentMsgs, formattedMsg] };\n            });\n        }\n    };\n\n    const markAsRead = async (chatId: string) => {\n        if (!user?.id) return;\n        await ChatService.markRoomAsRead(chatId, user.id);\n        setChats(prev => prev.map(chat => chat.id === chatId ? { ...chat, unreadCount: 0 } : chat));\n        setMessages(prev => {\n            const roomMsgs = prev[chatId];\n            if (!roomMsgs) return prev;\n            return { ...prev, [chatId]: roomMsgs.map(m => m.senderId !== user.id ? { ...m, status: 'read' } : m) };\n        });\n    };\n\n    const setTyping = async (chatId: string, isTyping: boolean) => {\n        if (channelRef.current) {\n            await channelRef.current.send({\n                type: 'broadcast',\n                event: 'typing',\n                payload: { chatId, userId: user?.id, isTyping },\n            });\n        }\n    };\n\n    const createChat = async (userId: string, userName: string, userAvatar: string): Promise<string> => {\n        const { data: roomId, error } = await ChatService.createDirectChat(userId);\n        if (error) throw new Error(error);\n        await loadInitialData();\n        return roomId!;\n    };\n\n    const sendRequest = async (userId: string) => {\n        const { error } = await ChatService.sendConnectionRequest(userId);\n        if (error) throw new Error(error);\n    };\n\n    const respondToRequest = async (requestId: string, status: 'accepted' | 'rejected'): Promise<string | null> => {\n        setLoading(true);\n        const { data: roomId, error } = await ChatService.respondToConnection(requestId, status);\n        if (error) {\n            setLoading(false);\n            return null;\n        }\n        setPendingRequests(prev => prev.filter(r => r.id !== requestId));\n        await loadInitialData();\n        setLoading(false);\n        return roomId;\n    };\n\n    const fetchMessages = async (chatId: string) => {\n        const { data, error } = await ChatService.getMessages(chatId);\n        if (!error && data) {\n            const formattedMsgs: Message[] = data.map(m => ({\n                id: m.id,\n                chatId: m.room_id,\n                senderId: m.user_id,\n                content: m.content,\n                type: m.message_type as any,\n                timestamp: new Date(m.created_at),\n                status: m.status,\n                mediaUrl: m.media_url,\n            }));\n            setMessages(prev => ({ ...prev, [chatId]: formattedMsgs }));\n        }\n    };\n\n    const refreshChats = async () => {\n        await loadInitialData();\n    };\n\n    const blockUser = async (userId: string) => {\n        const { error } = await ChatService.blockUser(userId);\n        if (error) throw new Error(error);\n        await refreshChats();\n    };\n\n    const unblockUser = async (userId: string) => {\n        const { error } = await ChatService.unblockUser(userId);\n        if (error) throw new Error(error);\n        await refreshChats();\n    };\n\n    const deleteGroup = async (roomId: string) => {\n        const { error } = await ChatService.deleteRoom(roomId);\n        if (error) throw new Error(error);\n        await refreshChats();\n    };\n\n    const updateGroup = async (roomId: string, updates: { name?: string; description?: string; avatar_url?: string }) => {\n        const { error } = await ChatService.updateRoom(roomId, updates);\n        if (error) throw new Error(error);\n        await refreshChats();\n    };\n\n    const getParticipants = async (roomId: string) => {\n        const { data, error } = await ChatService.getRoomParticipantsProfiles(roomId);\n        if (error) throw new Error(error);\n        return data || [];\n    };\n\n    const lockChat = async (chatId: string, pin: string) => {\n        const updated = { ...lockedChats, [chatId]: pin };\n        setLockedChats(updated);\n        localStorage.setItem('LOCKED_CHATS', JSON.stringify(updated));\n    };\n\n    const unlockChat = async (chatId: string) => {\n        const updated = { ...lockedChats };\n        delete updated[chatId];\n        setLockedChats(updated);\n        localStorage.setItem('LOCKED_CHATS', JSON.stringify(updated));\n    };\n\n    return (\n        <ChatContext.Provider value={{\n            chats, messages, pendingRequests, loading, sendMessage, markAsRead, setTyping, createChat, sendRequest, respondToRequest, refreshChats, blockUser, unblockUser, deleteGroup, fetchMessages, updateGroup, getParticipants,\n            lockedChats, lockChat, unlockChat\n        }}>\n            {children}\n        </ChatContext.Provider>\n    );\n}\n\nexport function useChat() {\n    const context = useContext(ChatContext);\n    if (!context) throw new Error('useChat must be used within ChatProvider');\n    return context;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1197, "column": 0}, "map": {"version":3,"sources":["file:///Users/apple/Desktop/GOSSIP/src/services/status-service.ts"],"sourcesContent":["import { safeSupabaseOperation } from '@/lib/supabase/client';\n\nexport interface StatusUpdate {\n    id: string;\n    user_id: string;\n    media_url: string;\n    caption: string | null;\n    created_at: string;\n    profiles?: any;\n}\n\nexport const StatusService = {\n    async getStatuses(): Promise<{ data: StatusUpdate[]; error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                // Fetch statuses from the last 24 hours\n                const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();\n\n                const { data, error } = await client\n                    .from('statuses')\n                    .select(`\n            *,\n            profiles (\n              id,\n              username,\n              full_name,\n              avatar_url\n            )\n          `)\n                    .gt('created_at', twentyFourHoursAgo)\n                    .order('created_at', { ascending: false });\n\n                if (error) return { data: [], error: error.message };\n                return { data: (data as StatusUpdate[]) || [], error: null };\n            });\n        } catch (err: any) {\n            return { data: [], error: err.message };\n        }\n    },\n\n    async uploadStatus(mediaUrl: string, caption?: string): Promise<{ error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                const { data: { user } } = await client.auth.getUser();\n                if (!user) throw new Error('Not authenticated');\n\n                const { error } = await client\n                    .from('statuses')\n                    .insert({\n                        user_id: user.id,\n                        media_url: mediaUrl,\n                        caption\n                    });\n\n                if (error) return { error: error.message };\n                return { error: null };\n            });\n        } catch (err: any) {\n            return { error: err.message };\n        }\n    }\n};\n"],"names":[],"mappings":";;;;AAAA;;AAWO,MAAM,gBAAgB;IACzB,MAAM;QACF,IAAI;YACA,OAAO,MAAM,IAAA,8KAAqB,EAAC,OAAO;gBACtC,wCAAwC;gBACxC,MAAM,qBAAqB,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,MAAM,WAAW;gBAEjF,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,OACzB,IAAI,CAAC,YACL,MAAM,CAAC,CAAC;;;;;;;;UAQnB,CAAC,EACU,EAAE,CAAC,cAAc,oBACjB,KAAK,CAAC,cAAc;oBAAE,WAAW;gBAAM;gBAE5C,IAAI,OAAO,OAAO;oBAAE,MAAM,EAAE;oBAAE,OAAO,MAAM,OAAO;gBAAC;gBACnD,OAAO;oBAAE,MAAM,AAAC,QAA2B,EAAE;oBAAE,OAAO;gBAAK;YAC/D;QACJ,EAAE,OAAO,KAAU;YACf,OAAO;gBAAE,MAAM,EAAE;gBAAE,OAAO,IAAI,OAAO;YAAC;QAC1C;IACJ;IAEA,MAAM,cAAa,QAAgB,EAAE,OAAgB;QACjD,IAAI;YACA,OAAO,MAAM,IAAA,8KAAqB,EAAC,OAAO;gBACtC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,GAAG,MAAM,OAAO,IAAI,CAAC,OAAO;gBACpD,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM;gBAE3B,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,OACnB,IAAI,CAAC,YACL,MAAM,CAAC;oBACJ,SAAS,KAAK,EAAE;oBAChB,WAAW;oBACX;gBACJ;gBAEJ,IAAI,OAAO,OAAO;oBAAE,OAAO,MAAM,OAAO;gBAAC;gBACzC,OAAO;oBAAE,OAAO;gBAAK;YACzB;QACJ,EAAE,OAAO,KAAU;YACf,OAAO;gBAAE,OAAO,IAAI,OAAO;YAAC;QAChC;IACJ;AACJ"}},
    {"offset": {"line": 1264, "column": 0}, "map": {"version":3,"sources":["file:///Users/apple/Desktop/GOSSIP/src/contexts/status-context.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';\nimport { useAuth } from './auth-context';\nimport { StatusService, StatusUpdate } from '@/services/status-service';\nimport { createClient } from '@/lib/supabase/client';\n\ninterface StatusContextType {\n    statuses: StatusUpdate[];\n    loading: boolean;\n    uploadStatus: (mediaUrl: string, caption?: string) => Promise<void>;\n    refreshStatuses: () => Promise<void>;\n}\n\nconst StatusContext = createContext<StatusContextType | undefined>(undefined);\n\nexport function StatusProvider({ children }: { children: ReactNode }) {\n    const [statuses, setStatuses] = useState<StatusUpdate[]>([]);\n    const [loading, setLoading] = useState(true);\n    const { user } = useAuth();\n    const supabase = createClient();\n\n    const loadStatuses = async () => {\n        setLoading(true);\n        const { data } = await StatusService.getStatuses();\n        if (data) setStatuses(data);\n        setLoading(false);\n    };\n\n    useEffect(() => {\n        if (user) {\n            loadStatuses();\n\n            const channel = supabase\n                .channel('public-statuses')\n                .on('postgres_changes', { event: '*', schema: 'public', table: 'statuses' }, () => {\n                    loadStatuses();\n                })\n                .subscribe();\n\n            return () => {\n                supabase.removeChannel(channel);\n            };\n        }\n    }, [user?.id]);\n\n    const uploadStatus = async (mediaUrl: string, caption?: string) => {\n        const { error } = await StatusService.uploadStatus(mediaUrl, caption);\n        if (error) throw new Error(error);\n    };\n\n    return (\n        <StatusContext.Provider value={{\n            statuses,\n            loading,\n            uploadStatus,\n            refreshStatuses: loadStatuses\n        }}>\n            {children}\n        </StatusContext.Provider>\n    );\n}\n\nexport function useStatus() {\n    const context = useContext(StatusContext);\n    if (!context) throw new Error('useStatus must be used within StatusProvider');\n    return context;\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;AACA;AALA;;;;;;AAcA,MAAM,8BAAgB,IAAA,2OAAa,EAAgC;AAE5D,SAAS,eAAe,EAAE,QAAQ,EAA2B;IAChE,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,sOAAQ,EAAiB,EAAE;IAC3D,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,sOAAQ,EAAC;IACvC,MAAM,EAAE,IAAI,EAAE,GAAG,IAAA,mKAAO;IACxB,MAAM,WAAW,IAAA,qKAAY;IAE7B,MAAM,eAAe;QACjB,WAAW;QACX,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,0KAAa,CAAC,WAAW;QAChD,IAAI,MAAM,YAAY;QACtB,WAAW;IACf;IAEA,IAAA,uOAAS,EAAC;QACN,IAAI,MAAM;YACN;YAEA,MAAM,UAAU,SACX,OAAO,CAAC,mBACR,EAAE,CAAC,oBAAoB;gBAAE,OAAO;gBAAK,QAAQ;gBAAU,OAAO;YAAW,GAAG;gBACzE;YACJ,GACC,SAAS;YAEd,OAAO;gBACH,SAAS,aAAa,CAAC;YAC3B;QACJ;IACJ,GAAG;QAAC,MAAM;KAAG;IAEb,MAAM,eAAe,OAAO,UAAkB;QAC1C,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,0KAAa,CAAC,YAAY,CAAC,UAAU;QAC7D,IAAI,OAAO,MAAM,IAAI,MAAM;IAC/B;IAEA,qBACI,mQAAC,cAAc,QAAQ;QAAC,OAAO;YAC3B;YACA;YACA;YACA,iBAAiB;QACrB;kBACK;;;;;;AAGb;AAEO,SAAS;IACZ,MAAM,UAAU,IAAA,wOAAU,EAAC;IAC3B,IAAI,CAAC,SAAS,MAAM,IAAI,MAAM;IAC9B,OAAO;AACX"}},
    {"offset": {"line": 1337, "column": 0}, "map": {"version":3,"sources":["file:///Users/apple/Desktop/GOSSIP/src/lib/utils.ts"],"sourcesContent":["import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,2LAAO,EAAC,IAAA,kKAAI,EAAC;AACtB"}},
    {"offset": {"line": 1352, "column": 0}, "map": {"version":3,"sources":["file:///Users/apple/Desktop/GOSSIP/src/components/ui/avatar.tsx"],"sourcesContent":["import { cn } from \"@/lib/utils\";\n\ninterface AvatarProps {\n    src?: string | null;\n    fallback: string;\n    className?: string;\n}\n\nexport function Avatar({ src, fallback, className }: AvatarProps) {\n    return (\n        <div className={cn(\"relative w-10 h-10 rounded-full overflow-hidden bg-muted flex items-center justify-center border border-border\", className)}>\n            {src ? (\n                <img src={src} alt={fallback} className=\"w-full h-full object-cover\" />\n            ) : (\n                <span className=\"font-medium text-muted-foreground uppercase\">{fallback.slice(0, 2)}</span>\n            )}\n        </div>\n    );\n}\n"],"names":[],"mappings":";;;;;AAAA;;;AAQO,SAAS,OAAO,EAAE,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAe;IAC5D,qBACI,mQAAC;QAAI,WAAW,IAAA,8IAAE,EAAC,kHAAkH;kBAChI,oBACG,mQAAC;YAAI,KAAK;YAAK,KAAK;YAAU,WAAU;;;;;iCAExC,mQAAC;YAAK,WAAU;sBAA+C,SAAS,KAAK,CAAC,GAAG;;;;;;;;;;;AAIjG"}},
    {"offset": {"line": 1389, "column": 0}, "map": {"version":3,"sources":["file:///Users/apple/Desktop/GOSSIP/src/components/call-overlay.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useRef, useState } from \"react\";\nimport { Mic, MicOff, Video, VideoOff, PhoneOff, Maximize2, Minimize2 } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport { Avatar } from \"./ui/avatar\";\nimport { useCall } from \"@/contexts/call-context\";\n\ninterface CallOverlayProps {\n    roomId: string;\n    currentUser: any;\n    minimize?: boolean;\n    onClose?: () => void;\n}\n\nexport function CallOverlay({ roomId, currentUser, minimize = false, onClose }: CallOverlayProps) {\n    const { localStream, remoteStream, callType, connectionState, signalingStatus, iceCandidateCount } = useCall();\n    const [isMinimized, setIsMinimized] = useState(minimize);\n    const [isMuted, setIsMuted] = useState(false);\n    const [isVideoOff, setIsVideoOff] = useState(false);\n\n    // Refs for media elements\n    const localVideoRef = useRef<HTMLVideoElement>(null);\n    const remoteVideoRef = useRef<HTMLVideoElement>(null);\n\n    useEffect(() => {\n        if (localVideoRef.current && localStream) {\n            localVideoRef.current.srcObject = localStream;\n        }\n    }, [localStream]);\n\n    useEffect(() => {\n        if (remoteVideoRef.current && remoteStream) {\n            remoteVideoRef.current.srcObject = remoteStream;\n            remoteVideoRef.current.play().catch(e => console.error(\"Error auto-playing video:\", e));\n        }\n    }, [remoteStream]);\n\n\n    const toggleMinimize = () => setIsMinimized(!isMinimized);\n\n    const toggleMute = () => {\n        if (localStream) {\n            localStream.getAudioTracks().forEach(track => track.enabled = !track.enabled);\n            setIsMuted(!isMuted);\n        }\n    }\n\n    const toggleVideo = () => {\n        if (localStream) {\n            localStream.getVideoTracks().forEach(track => track.enabled = !track.enabled);\n            setIsVideoOff(!isVideoOff);\n        }\n    }\n\n    const isAudioOnly = callType === 'audio';\n\n    return (\n        <div className={cn(\n            \"fixed transition-all duration-500 ease-in-out bg-black/90 backdrop-blur-md shadow-2xl border border-white/10 overflow-hidden z-50\",\n            isMinimized\n                ? \"bottom-4 right-4 w-72 h-48 rounded-2xl\"\n                : \"inset-4 rounded-3xl\"\n        )}>\n            {/* DEBUG OVERLAY */}\n            <div className=\"absolute top-4 left-4 z-50 bg-black/50 p-2 rounded text-xs text-white/70 font-mono pointer-events-none\">\n                <div>Signal: {signalingStatus}</div>\n                <div>WebRTC: {connectionState}</div>\n                <div>Candidates: {iceCandidateCount}</div>\n                <div>Type: {callType}</div>\n                <div>L-Tracks: {localStream?.getTracks().length || 0}</div>\n                <div>R-Tracks: {remoteStream?.getTracks().length || 0}</div>\n            </div>\n\n            {/* Main Video Area */}\n            <div className=\"relative w-full h-full flex items-center justify-center\">\n                {/* Remote Video or Audio Avatar */}\n                <div className=\"w-full h-full bg-zinc-900 flex items-center justify-center relative\">\n                    {/* Show Avatar if Audio Only OR No Remote Stream yet */}\n                    {(isAudioOnly || !remoteStream) && (\n                        <div className=\"flex flex-col items-center animate-pulse\">\n                            <Avatar fallback=\"Remote\" className=\"w-32 h-32 bg-zinc-800 text-zinc-500 mb-6 text-4xl\" />\n                            <p className=\"text-zinc-400 text-lg font-medium\">\n                                {connectionState === 'connected' ? 'Connected' : 'Connecting...'}\n                            </p>\n                        </div>\n                    )}\n\n                    {/* Video Element - Hidden if Audio Only */}\n                    <video\n                        ref={remoteVideoRef}\n                        autoPlay\n                        playsInline\n                        className={cn(\"absolute inset-0 w-full h-full object-cover\", (isAudioOnly || !remoteStream) && \"opacity-0 pointer-events-none\")}\n                    />\n                </div>\n\n                {/* Local Video (PIP) - Only show if Video Call */}\n                {!isAudioOnly && (\n                    <div className={cn(\n                        \"absolute transition-all duration-300 bg-zinc-800 rounded-xl overflow-hidden shadow-lg border border-white/10 z-10\",\n                        isMinimized ? \"hidden\" : \"top-4 right-4 w-48 h-36\"\n                    )}>\n                        <div className=\"w-full h-full flex items-center justify-center relative bg-black\">\n                            {!localStream && <span className=\"text-xs text-muted-foreground\">You</span>}\n                            <video ref={localVideoRef} autoPlay muted playsInline className=\"w-full h-full object-cover transform -scale-x-100\" />\n                        </div>\n                    </div>\n                )}\n\n                {/* Controls Overlay */}\n                <div className={cn(\n                    \"absolute bottom-0 left-0 right-0 p-6 bg-gradient-to-t from-black/80 to-transparent flex flex-col items-center justify-end transition-opacity z-20\",\n                    isMinimized ? \"opacity-0 hover:opacity-100\" : \"opacity-100\"\n                )}>\n                    {!isMinimized && (\n                        <div className=\"mb-8 text-center\">\n                            <h3 className=\"text-2xl font-bold text-white\">\n                                {isAudioOnly ? \"Voice Call\" : \"Video Call\"}\n                            </h3>\n                            <div className=\"flex items-center justify-center gap-2\">\n                                <span className={cn(\"w-2 h-2 rounded-full\", connectionState === 'connected' ? \"bg-green-500\" : \"bg-yellow-500\")}></span>\n                                <p className=\"text-white/60 capitalize\">{connectionState}</p>\n                            </div>\n                        </div>\n                    )}\n\n                    <div className=\"flex items-center gap-4\">\n                        <button onClick={toggleMute} className={cn(\"p-4 rounded-full transition-all\", isMuted ? \"bg-white text-black\" : \"bg-white/10 text-white hover:bg-white/20\")}>\n                            {isMuted ? <MicOff className=\"w-6 h-6\" /> : <Mic className=\"w-6 h-6\" />}\n                        </button>\n\n                        <button onClick={toggleVideo} className={cn(\"p-4 rounded-full transition-all\", isVideoOff ? \"bg-white text-black\" : \"bg-white/10 text-white hover:bg-white/20\")}>\n                            {isVideoOff ? <VideoOff className=\"w-6 h-6\" /> : <Video className=\"w-6 h-6\" />}\n                        </button>\n\n                        <button\n                            onClick={onClose}\n                            className=\"p-4 rounded-full bg-red-500 text-white hover:bg-red-600 transition-all shadow-lg hover:shadow-red-500/30 scale-100 hover:scale-110\"\n                        >\n                            <PhoneOff className=\"w-8 h-8\" />\n                        </button>\n\n                        <button onClick={toggleMinimize} className=\"p-4 rounded-full bg-white/10 text-white hover:bg-white/20 transition-all\">\n                            {isMinimized ? <Maximize2 className=\"w-6 h-6\" /> : <Minimize2 className=\"w-6 h-6\" />}\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AANA;;;;;;;AAeO,SAAS,YAAY,EAAE,MAAM,EAAE,WAAW,EAAE,WAAW,KAAK,EAAE,OAAO,EAAoB;IAC5F,MAAM,EAAE,WAAW,EAAE,YAAY,EAAE,QAAQ,EAAE,eAAe,EAAE,eAAe,EAAE,iBAAiB,EAAE,GAAG,IAAA,mKAAO;IAC5G,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,sOAAQ,EAAC;IAC/C,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,sOAAQ,EAAC;IACvC,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,sOAAQ,EAAC;IAE7C,0BAA0B;IAC1B,MAAM,gBAAgB,IAAA,oOAAM,EAAmB;IAC/C,MAAM,iBAAiB,IAAA,oOAAM,EAAmB;IAEhD,IAAA,uOAAS,EAAC;QACN,IAAI,cAAc,OAAO,IAAI,aAAa;YACtC,cAAc,OAAO,CAAC,SAAS,GAAG;QACtC;IACJ,GAAG;QAAC;KAAY;IAEhB,IAAA,uOAAS,EAAC;QACN,IAAI,eAAe,OAAO,IAAI,cAAc;YACxC,eAAe,OAAO,CAAC,SAAS,GAAG;YACnC,eAAe,OAAO,CAAC,IAAI,GAAG,KAAK,CAAC,CAAA,IAAK,QAAQ,KAAK,CAAC,6BAA6B;QACxF;IACJ,GAAG;QAAC;KAAa;IAGjB,MAAM,iBAAiB,IAAM,eAAe,CAAC;IAE7C,MAAM,aAAa;QACf,IAAI,aAAa;YACb,YAAY,cAAc,GAAG,OAAO,CAAC,CAAA,QAAS,MAAM,OAAO,GAAG,CAAC,MAAM,OAAO;YAC5E,WAAW,CAAC;QAChB;IACJ;IAEA,MAAM,cAAc;QAChB,IAAI,aAAa;YACb,YAAY,cAAc,GAAG,OAAO,CAAC,CAAA,QAAS,MAAM,OAAO,GAAG,CAAC,MAAM,OAAO;YAC5E,cAAc,CAAC;QACnB;IACJ;IAEA,MAAM,cAAc,aAAa;IAEjC,qBACI,mQAAC;QAAI,WAAW,IAAA,8IAAE,EACd,qIACA,cACM,2CACA;;0BAGN,mQAAC;gBAAI,WAAU;;kCACX,mQAAC;;4BAAI;4BAAS;;;;;;;kCACd,mQAAC;;4BAAI;4BAAS;;;;;;;kCACd,mQAAC;;4BAAI;4BAAa;;;;;;;kCAClB,mQAAC;;4BAAI;4BAAO;;;;;;;kCACZ,mQAAC;;4BAAI;4BAAW,aAAa,YAAY,UAAU;;;;;;;kCACnD,mQAAC;;4BAAI;4BAAW,cAAc,YAAY,UAAU;;;;;;;;;;;;;0BAIxD,mQAAC;gBAAI,WAAU;;kCAEX,mQAAC;wBAAI,WAAU;;4BAEV,CAAC,eAAe,CAAC,YAAY,mBAC1B,mQAAC;gCAAI,WAAU;;kDACX,mQAAC,iKAAM;wCAAC,UAAS;wCAAS,WAAU;;;;;;kDACpC,mQAAC;wCAAE,WAAU;kDACR,oBAAoB,cAAc,cAAc;;;;;;;;;;;;0CAM7D,mQAAC;gCACG,KAAK;gCACL,QAAQ;gCACR,WAAW;gCACX,WAAW,IAAA,8IAAE,EAAC,+CAA+C,CAAC,eAAe,CAAC,YAAY,KAAK;;;;;;;;;;;;oBAKtG,CAAC,6BACE,mQAAC;wBAAI,WAAW,IAAA,8IAAE,EACd,qHACA,cAAc,WAAW;kCAEzB,cAAA,mQAAC;4BAAI,WAAU;;gCACV,CAAC,6BAAe,mQAAC;oCAAK,WAAU;8CAAgC;;;;;;8CACjE,mQAAC;oCAAM,KAAK;oCAAe,QAAQ;oCAAC,KAAK;oCAAC,WAAW;oCAAC,WAAU;;;;;;;;;;;;;;;;;kCAM5E,mQAAC;wBAAI,WAAW,IAAA,8IAAE,EACd,qJACA,cAAc,gCAAgC;;4BAE7C,CAAC,6BACE,mQAAC;gCAAI,WAAU;;kDACX,mQAAC;wCAAG,WAAU;kDACT,cAAc,eAAe;;;;;;kDAElC,mQAAC;wCAAI,WAAU;;0DACX,mQAAC;gDAAK,WAAW,IAAA,8IAAE,EAAC,wBAAwB,oBAAoB,cAAc,iBAAiB;;;;;;0DAC/F,mQAAC;gDAAE,WAAU;0DAA4B;;;;;;;;;;;;;;;;;;0CAKrD,mQAAC;gCAAI,WAAU;;kDACX,mQAAC;wCAAO,SAAS;wCAAY,WAAW,IAAA,8IAAE,EAAC,mCAAmC,UAAU,wBAAwB;kDAC3G,wBAAU,mQAAC,yOAAM;4CAAC,WAAU;;;;;iEAAe,mQAAC,4NAAG;4CAAC,WAAU;;;;;;;;;;;kDAG/D,mQAAC;wCAAO,SAAS;wCAAa,WAAW,IAAA,8IAAE,EAAC,mCAAmC,aAAa,wBAAwB;kDAC/G,2BAAa,mQAAC,+OAAQ;4CAAC,WAAU;;;;;iEAAe,mQAAC,kOAAK;4CAAC,WAAU;;;;;;;;;;;kDAGtE,mQAAC;wCACG,SAAS;wCACT,WAAU;kDAEV,cAAA,mQAAC,+OAAQ;4CAAC,WAAU;;;;;;;;;;;kDAGxB,mQAAC;wCAAO,SAAS;wCAAgB,WAAU;kDACtC,4BAAc,mQAAC,kPAAS;4CAAC,WAAU;;;;;iEAAe,mQAAC,kPAAS;4CAAC,WAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOpG"}},
    {"offset": {"line": 1757, "column": 0}, "map": {"version":3,"sources":["file:///Users/apple/Desktop/GOSSIP/src/contexts/call-context.tsx"],"sourcesContent":["\"use client\";\n\nimport { createContext, useContext, useEffect, useRef, useState } from \"react\";\n\nimport { createClient } from \"@/lib/supabase/client\";\nimport { RealtimeChannel } from \"@supabase/supabase-js\";\nimport { CallOverlay } from \"@/components/call-overlay\";\n\ndeclare global {\n    interface Window {\n        iceErrorShown: boolean;\n    }\n}\n\ninterface CallContextType {\n    isInCall: boolean;\n    isIncomingCall: boolean;\n    callDetails: any;\n    startCall: (roomId: string, isVideo?: boolean) => Promise<void>;\n    acceptCall: () => Promise<void>;\n    endCall: () => Promise<void>;\n    localStream: MediaStream | null;\n    remoteStream: MediaStream | null;\n    callType: \"video\" | \"audio\";\n    connectionState: string;\n    signalingStatus: string;\n    iceCandidateCount: number;\n    callHistory: any[];\n    loading: boolean;\n    initiateCall: (receiverId: string, type: 'audio' | 'video') => Promise<void>;\n}\n\nconst CallContext = createContext<CallContextType | null>(null);\n\nexport function useCall() {\n    const context = useContext(CallContext);\n    if (!context) throw new Error(\"useCall must be used within a CallProvider\");\n    return context;\n}\n\nimport { useAuth } from \"./auth-context\";\n\nexport function CallProvider({ children }: { children: React.ReactNode }) {\n    const { user } = useAuth();\n    const [callDetails, setCallDetails] = useState<any>(null);\n    const [localStream, setLocalStream] = useState<MediaStream | null>(null);\n    const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);\n    const [incomingCall, setIncomingCall] = useState<any>(null);\n    const [callType, setCallType] = useState<\"video\" | \"audio\">(\"video\");\n    const [connectionState, setConnectionState] = useState<string>(\"new\");\n    const [signalingStatus, setSignalingStatus] = useState<string>(\"disconnected\");\n    const [iceCandidateCount, setIceCandidateCount] = useState<number>(0);\n    const [callHistory, setCallHistory] = useState<any[]>([]);\n    const [loading, setLoading] = useState(true);\n\n    // WebRTC refs\n    const peerConnection = useRef<RTCPeerConnection | null>(null);\n    const supabase = createClient();\n    const signalingChannel = useRef<RealtimeChannel | null>(null);\n\n\n\n    const candidateQueue = useRef<any[]>([]); // Queue for early candidates\n\n    // ICE servers (STUN) - Expanded list for better connectivity\n    const pcConfig = {\n        iceServers: [\n            { urls: 'stun:stun.l.google.com:19302' },\n            { urls: 'stun:stun1.l.google.com:19302' },\n            { urls: 'stun:stun2.l.google.com:19302' },\n            { urls: 'stun:global.stun.twilio.com:3478' }\n        ]\n    };\n\n    // 1. Listen for incoming calls\n    useEffect(() => {\n        if (!user) return;\n\n        console.log(\"Listening for calls on user channel:\", user.id);\n        const channel = supabase\n            .channel(`calls:${user.id}`)\n            .on(\n                'postgres_changes',\n                { event: 'INSERT', schema: 'public', table: 'calls', filter: `caller_id=neq.${user.id}` }, // Simply listening for ANY insert might be too broad if not filtering by recipients, but schema is simple. \n                // Wait, the schema 'calls' table has 'room_id'. It doesn't explicitly have 'recipient_id'. \n                // We should probably listen to \"calls\" where I am in the \"room_participants\". \n                // For simplicity/MVP, I'll listen to ALL INSERTs on 'calls' and then check if I'm in the room (client-side filtering) or if it's meant for me.\n                // Actually, a better query would be filtering by my user ID if I had a 'recipient_id' column.\n                // Given current schema, I will subscribe to the global 'calls' table but in a real app this is bad. \n                // Let's rely on the fact that we can subscribe to changes on the Calls table.\n                async (payload) => {\n                    console.log(\"New call detected:\", payload);\n                    // Check if I am a participant in this room?\n                    // For now, let's just show it if it's NOT my own call.\n                    if (payload.new.caller_id !== user.id && payload.new.status === 'active') {\n                        // TODO: Verify if user belongs to payload.new.room_id\n                        setIncomingCall(payload.new);\n                    }\n                }\n            )\n            .subscribe();\n\n        return () => {\n            supabase.removeChannel(channel);\n        };\n    }, [user, supabase]);\n\n    // 2. Fetch call history\n    useEffect(() => {\n        const fetchHistory = async () => {\n            setLoading(true);\n            const { data } = await CallService.getCallHistory();\n            if (data) setCallHistory(data);\n            setLoading(false);\n        };\n\n        if (user) {\n            fetchHistory();\n\n            // Subscribe to call changes to refresh history\n            const channel = supabase\n                .channel('call_history_updates')\n                .on('postgres_changes', { event: '*', schema: 'public', table: 'calls' }, () => {\n                    fetchHistory();\n                })\n                .subscribe();\n\n            return () => {\n                supabase.removeChannel(channel);\n            };\n        }\n    }, [user, supabase]);\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => {\n            localStream?.getTracks().forEach(track => track.stop());\n            peerConnection.current?.close();\n        };\n    }, []);\n\n    // We need a ref to store the current call ID for the callback\n    const currentCallIdRef = useRef<string | null>(null);\n    const remoteCandidateQueue = useRef<RTCIceCandidateInit[]>([]); // Buffer for incoming candidates\n\n    const startCall = async (roomId: string, isVideo = true) => {\n        try {\n            setIceCandidateCount(0);\n            const type = isVideo ? 'video' : 'audio';\n            setCallType(type);\n\n            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n                alert(\"Browser not supported (getUserMedia missing).\");\n                return;\n            }\n\n            const stream = await navigator.mediaDevices.getUserMedia({ video: isVideo, audio: true });\n            setLocalStream(stream);\n\n            // Create PC first\n            const pc = new RTCPeerConnection(pcConfig);\n            peerConnection.current = pc;\n            remoteCandidateQueue.current = []; // Reset queue\n\n            // Standard \"Add Track\" pattern\n            stream.getTracks().forEach(track => {\n                pc.addTrack(track, stream);\n            });\n\n            // Force ALL transceivers to sendrecv (ensure bidirectional)\n            pc.getTransceivers().forEach(t => {\n                if (t.direction !== 'stopped') {\n                    t.direction = 'sendrecv';\n                }\n            });\n\n            // Queue for local candidates generated before Call ID is ready\n            const localQueuedCandidates: RTCIceCandidate[] = [];\n\n            // Bind ICE handler IMMEDIATELY\n            pc.onicecandidate = async (event) => {\n                if (event.candidate) {\n                    setIceCandidateCount(prev => prev + 1);\n\n                    if (currentCallIdRef.current) {\n                        // Call ID ready, send immediately\n                        const { error } = await supabase.from('ice_candidates').insert({\n                            call_id: currentCallIdRef.current,\n                            candidate: event.candidate,\n                            sender_id: user?.id\n                        });\n                        if (error) console.error(\"ICE Insert Error:\", error);\n                    } else {\n                        // Call ID not ready, queue it\n                        console.log(\"Queueing local candidate (Call ID not ready)\");\n                        localQueuedCandidates.push(event.candidate);\n                    }\n                }\n            };\n\n            // Bind other events\n            pc.ontrack = (event) => {\n                console.log(\"Track received:\", event.track.kind, event.streams[0]);\n                setRemoteStream(new MediaStream(event.streams[0].getTracks()));\n            };\n            pc.onconnectionstatechange = () => {\n                console.log(\"Connection state changes:\", pc.connectionState);\n                setConnectionState(pc.connectionState);\n            };\n\n\n\n            // Create Offer\n            const offer = await pc.createOffer();\n            await pc.setLocalDescription(offer);\n\n            // Create Call in DB\n            const { data: call, error } = await supabase.from('calls').insert({\n                room_id: roomId,\n                caller_id: user?.id,\n                status: 'active',\n                offer: offer,\n                type: type\n            }).select().single();\n\n            if (error) throw error;\n\n            setCallDetails(call);\n            currentCallIdRef.current = call.id; // Set ref for ICE callback\n\n            // FLUSH QUEUED CANDIDATES\n            if (localQueuedCandidates.length > 0) {\n                console.log(`Flushing ${localQueuedCandidates.length} queued local candidates`);\n                const inserts = localQueuedCandidates.map(c => ({\n                    call_id: call.id,\n                    candidate: c,\n                    sender_id: user?.id\n                }));\n                const { error: flushError } = await supabase.from('ice_candidates').insert(inserts);\n                if (flushError) console.error(\"Error flushing local candidates:\", flushError);\n            }\n\n            // Setup DB handlers\n            setupSignaling(call.id);\n\n\n\n        } catch (err: any) {\n            console.error(\"Error starting call:\", err);\n            alert(`Call failed: ${err.message}`);\n        }\n    };\n\n    const acceptCall = async () => {\n        if (!incomingCall) return;\n\n        try {\n            setIceCandidateCount(0);\n            // ... getUserMedia logic ...\n            const isVideo = incomingCall.type === 'video';\n            setCallType(incomingCall.type || 'video');\n\n            const stream = await navigator.mediaDevices.getUserMedia({ video: isVideo, audio: true });\n            setLocalStream(stream);\n\n            const pc = new RTCPeerConnection(pcConfig);\n            peerConnection.current = pc;\n            currentCallIdRef.current = incomingCall.id;\n            remoteCandidateQueue.current = []; // Reset queue\n\n            // Bind events IMMEDIATELY\n            pc.onicecandidate = async (event) => {\n                if (event.candidate) {\n                    setIceCandidateCount(prev => prev + 1);\n                    const { error } = await supabase.from('ice_candidates').insert({\n                        call_id: incomingCall.id,\n                        candidate: event.candidate,\n                        sender_id: user?.id\n                    });\n                    if (error) console.error(\"ICE Insert Error:\", error);\n                }\n            };\n\n            pc.ontrack = (event) => {\n                console.log(\"Track received:\", event.track.kind, event.streams[0]);\n                setRemoteStream(new MediaStream(event.streams[0].getTracks()));\n            };\n\n            pc.onconnectionstatechange = () => {\n                console.log(\"Connection state changes:\", pc.connectionState);\n                setConnectionState(pc.connectionState);\n            };\n\n            // 1. Set Offer FIRST (This creates the receivers/transceivers from the caller)\n            await pc.setRemoteDescription(new RTCSessionDescription(incomingCall.offer));\n\n            // 2. Add our tracks to the existing transceivers\n            stream.getTracks().forEach(track => {\n                try {\n                    pc.addTrack(track, stream);\n                } catch (e) {\n                    console.error(\"Error adding track:\", e);\n                }\n            });\n\n            // Force ALL transceivers to sendrecv (crucial for Receiver to send back)\n            pc.getTransceivers().forEach(t => {\n                if (t.direction !== 'stopped') {\n                    t.direction = 'sendrecv';\n                }\n            });\n\n\n\n\n\n            // Create Answer\n            const answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n\n            // Update DB - Answer\n            const { error: updateError } = await supabase.from('calls').update({\n                answer: answer,\n                status: 'active'\n            }).eq('id', incomingCall.id);\n\n            if (updateError) throw updateError;\n\n            setCallDetails(incomingCall);\n            setIncomingCall(null);\n\n            setupSignaling(incomingCall.id);\n\n            // Fetch existing candidates!\n            const { data: existingCandidates, error: fetchError } = await supabase\n                .from('ice_candidates')\n                .select('*')\n                .eq('call_id', incomingCall.id)\n                .neq('sender_id', user?.id || '');\n\n            if (fetchError) console.error(\"Error fetching candidates:\", fetchError);\n\n            if (existingCandidates) {\n                console.log(`Found ${existingCandidates.length} existing candidates`);\n                // If we are accepting, we have already set RemoteDescription (Offer) above.\n                // So we can add them safely.\n                existingCandidates.forEach(async (c) => {\n                    await pc.addIceCandidate(new RTCIceCandidate(c.candidate));\n                });\n            }\n\n        } catch (err: any) {\n            console.error(\"Error accepting call:\", err);\n            alert(`Accept call failed: ${err.message}`);\n        }\n    };\n\n    const endCall = async () => {\n        // Close connections\n        localStream?.getTracks().forEach(track => track.stop());\n        peerConnection.current?.close();\n\n        // Update DB\n        if (callDetails) {\n            await supabase.from('calls').update({ status: 'ended' }).eq('id', callDetails.id);\n        }\n\n        // Reset state\n        setLocalStream(null);\n        setRemoteStream(null);\n        setCallDetails(null);\n        setIncomingCall(null);\n        setConnectionState(\"new\"); // Reset connection state\n        if (signalingChannel.current) {\n            await supabase.removeChannel(signalingChannel.current);\n            signalingChannel.current = null;\n        }\n        currentCallIdRef.current = null;\n    };\n\n    const processCandidateQueue = async () => {\n        if (!peerConnection.current || !remoteCandidateQueue.current.length) return;\n\n        console.log(`Processing ${remoteCandidateQueue.current.length} queued remote candidates.`);\n        for (const candidate of remoteCandidateQueue.current) {\n            try {\n                await peerConnection.current.addIceCandidate(new RTCIceCandidate(candidate));\n            } catch (e) {\n                console.error(\"Error flushing candidate from queue:\", e);\n            }\n        }\n        remoteCandidateQueue.current = [];\n    };\n\n    const setupSignaling = (callId: string) => {\n        // Cleanup existing channel if any\n        if (signalingChannel.current) {\n            supabase.removeChannel(signalingChannel.current);\n            signalingChannel.current = null;\n        }\n\n        // Subscribe to Call Updates (Answer/Status) AND ICE Candidates\n        const channel = supabase.channel(`call_signaling:${callId}`);\n        setSignalingStatus(\"initializing\");\n\n        channel\n            // Listen for ICE Candidates inserted into DB\n            .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'ice_candidates', filter: `call_id=eq.${callId}` }, async (payload) => {\n                // Ignore my own candidates\n                if (payload.new.sender_id === user?.id) return;\n\n                if (peerConnection.current && peerConnection.current.signalingState !== 'closed') {\n                    console.log(\"Received new ICE candidate from DB via Realtime\");\n\n                    // Attempt to add, with fallback to queue\n                    const pc = peerConnection.current;\n                    const candidate = new RTCIceCandidate(payload.new.candidate);\n\n                    if (pc.remoteDescription && pc.signalingState !== 'have-local-offer') { // Extra check for stability\n                        try {\n                            await pc.addIceCandidate(candidate);\n                            console.log(\"Successfully added ICE candidate\");\n                        } catch (e: any) {\n                            console.error(\"Error adding live candidate:\", e);\n                            // Self-healing: If it failed due to remote description or state, QUEUE IT\n                            if (e.message?.includes(\"remote description\") || e.name === 'InvalidStateError') {\n                                console.log(\"Add failed (remote desc missing/invalid state). Re-queueing candidate.\");\n                                remoteCandidateQueue.current.push(payload.new.candidate);\n                            }\n                        }\n                    } else {\n                        console.log(\"Remote description not set (or unstable). Queueing candidate.\");\n                        remoteCandidateQueue.current.push(payload.new.candidate);\n                    }\n                }\n            })\n            // Listen for Call Updates (Answer, End)\n            .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'calls', filter: `id=eq.${callId}` }, async (payload) => {\n                if (payload.new.answer && !peerConnection.current?.currentRemoteDescription) {\n                    console.log(\"Received Answer via Realtime\");\n                    const answer = payload.new.answer;\n                    await peerConnection.current?.setRemoteDescription(new RTCSessionDescription(answer));\n\n                    // Now that remote description is set, process any queued candidates\n                    await processCandidateQueue();\n                }\n\n                if (payload.new.status === 'ended') {\n                    endCall();\n                }\n            })\n            .subscribe((status) => {\n                console.log(\"Signaling Channel Status:\", status);\n                setSignalingStatus(status);\n            });\n\n        signalingChannel.current = channel;\n    };\n\n    const initiateCall = async (receiverId: string, type: 'audio' | 'video') => {\n        if (!user) return;\n\n        // Find existing DM room or create one\n        const { data: rooms } = await supabase\n            .from('room_participants')\n            .select('room_id')\n            .eq('user_id', user.id);\n\n        let roomId: string | null = null;\n\n        if (rooms && rooms.length > 0) {\n            const myRoomIds = rooms.map(r => r.room_id);\n            const { data: sharedRooms } = await supabase\n                .from('room_participants')\n                .select('room_id')\n                .eq('user_id', receiverId)\n                .in('room_id', myRoomIds);\n\n            if (sharedRooms && sharedRooms.length > 0) {\n                // Check if any of these is a DM\n                const { data: dmRoom } = await supabase\n                    .from('rooms')\n                    .select('id')\n                    .eq('is_group', false)\n                    .in('id', sharedRooms.map(r => r.room_id))\n                    .maybeSingle();\n\n                if (dmRoom) roomId = dmRoom.id;\n            }\n        }\n\n        if (!roomId) {\n            const { data: newRoom } = await supabase\n                .from('rooms')\n                .insert({ is_group: false, updated_at: new Date().toISOString() })\n                .select()\n                .single();\n\n            if (newRoom) {\n                roomId = newRoom.id;\n                await supabase.from('room_participants').insert([\n                    { room_id: roomId, user_id: user.id },\n                    { room_id: roomId, user_id: receiverId }\n                ]);\n            }\n        }\n\n        if (roomId) {\n            await startCall(roomId, type === 'video');\n        }\n    };\n\n    return (\n        <CallContext.Provider value={{\n            isInCall: !!callDetails,\n            isIncomingCall: !!incomingCall,\n            callDetails: callDetails || incomingCall,\n            startCall,\n            acceptCall,\n            endCall,\n            localStream,\n            remoteStream,\n            callType,\n            connectionState,\n            signalingStatus,\n            iceCandidateCount,\n            callHistory,\n            loading,\n            initiateCall\n        }}>\n            {children}\n            {/* Global Call Overlay */}\n            {incomingCall && !callDetails && (\n                <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm\">\n                    <div className=\"glass-card p-8 rounded-2xl flex flex-col items-center gap-4 animate-float\">\n                        <div className=\"w-20 h-20 rounded-full bg-primary/20 flex items-center justify-center animate-pulse\">\n                            <div className=\"w-16 h-16 rounded-full bg-primary flex items-center justify-center text-white\">\n                                {incomingCall.type === 'audio' ? '' : ''}\n                            </div>\n                        </div>\n                        <h3 className=\"text-xl font-bold\">Incoming {incomingCall.type === 'audio' ? 'Voice' : 'Video'} Call...</h3>\n                        <div className=\"flex gap-4\">\n                            <button onClick={acceptCall} className=\"px-6 py-2 bg-green-500 rounded-full text-white font-medium hover:bg-green-600 transition-colors\">Accept</button>\n                            <button onClick={() => setIncomingCall(null)} className=\"px-6 py-2 bg-red-500 rounded-full text-white font-medium hover:bg-red-600 transition-colors\">Decline</button>\n                        </div>\n                    </div>\n                </div>\n            )}\n\n            {callDetails && (\n                <CallOverlay roomId={callDetails.room_id} currentUser={user} onClose={endCall} />\n            )}\n        </CallContext.Provider>\n    );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2295, "column": 0}, "map": {"version":3,"sources":["file:///Users/apple/Desktop/GOSSIP/src/contexts/toast-context.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { createContext, useContext, useState, useCallback, ReactNode } from \"react\";\nimport { X, CheckCircle, AlertCircle, Info, AlertTriangle } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\n\ntype ToastType = \"success\" | \"error\" | \"info\" | \"warning\";\n\ninterface Toast {\n    id: string;\n    message: string;\n    type: ToastType;\n}\n\ninterface ToastContextType {\n    toasts: Toast[];\n    addToast: (message: string, type?: ToastType) => void;\n    removeToast: (id: string) => void;\n}\n\nconst ToastContext = createContext<ToastContextType | undefined>(undefined);\n\nexport function ToastProvider({ children }: { children: ReactNode }) {\n    const [toasts, setToasts] = useState<Toast[]>([]);\n\n    const addToast = useCallback((message: string, type: ToastType = \"info\") => {\n        const id = Math.random().toString(36).substring(2, 9);\n        setToasts((prev) => [...prev, { id, message, type }]);\n\n        // Auto-remove after 3 seconds\n        setTimeout(() => {\n            setToasts((prev) => prev.filter((t) => t.id !== id));\n        }, 3000);\n    }, []);\n\n    const removeToast = useCallback((id: string) => {\n        setToasts((prev) => prev.filter((t) => t.id !== id));\n    }, []);\n\n    return (\n        <ToastContext.Provider value={{ toasts, addToast, removeToast }}>\n            {children}\n            <div className=\"fixed top-4 right-4 z-[100] flex flex-col gap-2 pointer-events-none\">\n                {toasts.map((toast) => (\n                    <div\n                        key={toast.id}\n                        className={cn(\n                            \"pointer-events-auto min-w-[300px] max-w-sm p-4 rounded-xl shadow-lg border backdrop-blur-md flex items-start gap-3 animate-in slide-in-from-right-full fade-in duration-300\",\n                            toast.type === \"success\" && \"bg-green-500/10 border-green-500/20 text-green-500\",\n                            toast.type === \"error\" && \"bg-red-500/10 border-red-500/20 text-red-500\",\n                            toast.type === \"warning\" && \"bg-yellow-500/10 border-yellow-500/20 text-yellow-500\",\n                            toast.type === \"info\" && \"bg-blue-500/10 border-blue-500/20 text-blue-500\"\n                        )}\n                    >\n                        {toast.type === \"success\" && <CheckCircle className=\"w-5 h-5 shrink-0\" />}\n                        {toast.type === \"error\" && <AlertCircle className=\"w-5 h-5 shrink-0\" />}\n                        {toast.type === \"warning\" && <AlertTriangle className=\"w-5 h-5 shrink-0\" />}\n                        {toast.type === \"info\" && <Info className=\"w-5 h-5 shrink-0\" />}\n\n                        <div className=\"flex-1 text-sm font-medium\">{toast.message}</div>\n\n                        <button onClick={() => removeToast(toast.id)} className=\"opacity-70 hover:opacity-100\">\n                            <X className=\"w-4 h-4\" />\n                        </button>\n                    </div>\n                ))}\n            </div>\n        </ToastContext.Provider>\n    );\n}\n\nexport function useToast() {\n    const context = useContext(ToastContext);\n    if (!context) {\n        throw new Error(\"useToast must be used within a ToastProvider\");\n    }\n    return context;\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAJA;;;;;AAoBA,MAAM,6BAAe,IAAA,2OAAa,EAA+B;AAE1D,SAAS,cAAc,EAAE,QAAQ,EAA2B;IAC/D,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,sOAAQ,EAAU,EAAE;IAEhD,MAAM,WAAW,IAAA,yOAAW,EAAC,CAAC,SAAiB,OAAkB,MAAM;QACnE,MAAM,KAAK,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG;QACnD,UAAU,CAAC,OAAS;mBAAI;gBAAM;oBAAE;oBAAI;oBAAS;gBAAK;aAAE;QAEpD,8BAA8B;QAC9B,WAAW;YACP,UAAU,CAAC,OAAS,KAAK,MAAM,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;QACpD,GAAG;IACP,GAAG,EAAE;IAEL,MAAM,cAAc,IAAA,yOAAW,EAAC,CAAC;QAC7B,UAAU,CAAC,OAAS,KAAK,MAAM,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;IACpD,GAAG,EAAE;IAEL,qBACI,mQAAC,aAAa,QAAQ;QAAC,OAAO;YAAE;YAAQ;YAAU;QAAY;;YACzD;0BACD,mQAAC;gBAAI,WAAU;0BACV,OAAO,GAAG,CAAC,CAAC,sBACT,mQAAC;wBAEG,WAAW,IAAA,8IAAE,EACT,+KACA,MAAM,IAAI,KAAK,aAAa,sDAC5B,MAAM,IAAI,KAAK,WAAW,gDAC1B,MAAM,IAAI,KAAK,aAAa,yDAC5B,MAAM,IAAI,KAAK,UAAU;;4BAG5B,MAAM,IAAI,KAAK,2BAAa,mQAAC,+PAAW;gCAAC,WAAU;;;;;;4BACnD,MAAM,IAAI,KAAK,yBAAW,mQAAC,wPAAW;gCAAC,WAAU;;;;;;4BACjD,MAAM,IAAI,KAAK,2BAAa,mQAAC,8PAAa;gCAAC,WAAU;;;;;;4BACrD,MAAM,IAAI,KAAK,wBAAU,mQAAC,+NAAI;gCAAC,WAAU;;;;;;0CAE1C,mQAAC;gCAAI,WAAU;0CAA8B,MAAM,OAAO;;;;;;0CAE1D,mQAAC;gCAAO,SAAS,IAAM,YAAY,MAAM,EAAE;gCAAG,WAAU;0CACpD,cAAA,mQAAC,sNAAC;oCAAC,WAAU;;;;;;;;;;;;uBAjBZ,MAAM,EAAE;;;;;;;;;;;;;;;;AAwBrC;AAEO,SAAS;IACZ,MAAM,UAAU,IAAA,wOAAU,EAAC;IAC3B,IAAI,CAAC,SAAS;QACV,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;AACX"}},
    {"offset": {"line": 2428, "column": 0}, "map": {"version":3,"sources":["file:///Users/apple/Desktop/GOSSIP/src/components/providers.tsx"],"sourcesContent":["\"use client\";\n\nimport { AuthProvider } from \"@/contexts/auth-context\";\nimport { ChatProvider } from \"@/contexts/chat-context\";\nimport { StatusProvider } from \"@/contexts/status-context\";\nimport { CallProvider } from \"@/contexts/call-context\";\nimport { ToastProvider } from \"@/contexts/toast-context\";\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n    return (\n        <AuthProvider>\n            <ToastProvider>\n                <StatusProvider>\n                    <ChatProvider>\n                        <CallProvider>\n                            {children}\n                        </CallProvider>\n                    </ChatProvider>\n                </StatusProvider>\n            </ToastProvider>\n        </AuthProvider>\n    );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;AANA;;;;;;;AAQO,SAAS,UAAU,EAAE,QAAQ,EAAiC;IACjE,qBACI,mQAAC,wKAAY;kBACT,cAAA,mQAAC,0KAAa;sBACV,cAAA,mQAAC,4KAAc;0BACX,cAAA,mQAAC,wKAAY;8BACT,cAAA,mQAAC,wKAAY;kCACR;;;;;;;;;;;;;;;;;;;;;;;;;;AAO7B"}}]
}