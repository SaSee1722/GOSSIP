{"version":3,"sources":["../../../../../../Desktop/GOSSIP/src/services/chat-service.ts","../../../../../../Desktop/GOSSIP/src/services/notification-service.ts","../../../../../../Desktop/GOSSIP/src/contexts/chat-context.tsx"],"sourcesContent":["import { safeSupabaseOperation } from '@/lib/supabase/client';\nimport { sendPushNotification } from '@/services/notification-service';\n\nexport interface Room {\n    id: string;\n    name: string | null;\n    description: string | null;\n    type: 'direct' | 'group';\n    created_by: string;\n    created_at: string;\n    avatar_url: string | null;\n}\n\nexport interface MessageData {\n    id: string;\n    room_id: string;\n    user_id: string;\n    content: string;\n    message_type: 'text' | 'image' | 'video' | 'audio' | 'document';\n    media_url?: string;\n    status: 'sent' | 'delivered' | 'read';\n    created_at: string;\n}\n\nexport const ChatService = {\n    async getMyRooms(): Promise<{ data: any[]; error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                const { data: { user } } = await client.auth.getUser();\n                if (!user) throw new Error('Not authenticated');\n\n                console.log('[ChatService] Fetching rooms for user:', user.id);\n\n                // Step 1: Get My Room IDs\n                const { data: myParticipations, error: partError } = await client\n                    .from('room_participants')\n                    .select('room_id')\n                    .eq('user_id', user.id);\n\n                if (partError) {\n                    console.error('[ChatService] Error fetching participations:', partError);\n                    return { data: [], error: partError.message };\n                }\n\n                if (!myParticipations || myParticipations.length === 0) {\n                    console.log('[ChatService] No participations found.');\n                    return { data: [], error: null };\n                }\n\n                const roomIds = myParticipations.map(p => p.room_id);\n\n                // Step 2: Fetch Rooms with Full Details\n                const { data: roomsData, error: roomsError } = await client\n                    .from('rooms')\n                    .select(`\n                        *,\n                        participants:room_participants(\n                            user_id,\n                            profiles(username, full_name, avatar_url, gender, is_online, last_seen)\n                        )\n                    `)\n                    .in('id', roomIds)\n                    .order('created_at', { ascending: false });\n\n                if (roomsError) {\n                    console.error('[ChatService] Error fetching rooms:', roomsError);\n                    return { data: [], error: roomsError.message };\n                }\n\n                // Get Blocked Users\n                const { data: blockedData } = await client\n                    .from('blocked_users')\n                    .select('blocked_id')\n                    .eq('blocker_id', user.id);\n                const blockedIds = new Set((blockedData || []).map((b: any) => b.blocked_id));\n\n                // Transform and Filter\n                const seenPartners = new Set<string>();\n\n                const finalRooms = roomsData.map((room: any) => ({\n                    ...room,\n                    room_participants: room.participants // Map to expected structure for Sidebar\n                })).filter((room: any) => {\n                    if (room.type === 'direct') {\n                        const other = room.participants.find((p: any) => p.user_id !== user.id);\n                        // Check blocked\n                        if (other && blockedIds.has(other.user_id)) return false;\n\n                        // Check duplicates\n                        if (other) {\n                            if (seenPartners.has(other.user_id)) return false;\n                            seenPartners.add(other.user_id);\n                        }\n                    }\n                    return true;\n                });\n\n                console.log('[ChatService] Returning rooms:', finalRooms.length);\n                return { data: finalRooms, error: null };\n            });\n        } catch (err: any) {\n            console.error('[ChatService] getMyRooms exception:', err);\n            return { data: [], error: err.message };\n        }\n    },\n\n    async getRoomParticipants(roomId: string): Promise<{ data: any[]; error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                const { data, error } = await client\n                    .from('room_participants')\n                    .select(`\n            user_id,\n            profiles (\n              id,\n              username,\n              full_name,\n              avatar_url,\n              is_online,\n              last_seen,\n              gender,\n              age\n            )\n          `)\n                    .eq('room_id', roomId);\n\n                if (error) return { data: [], error: error.message };\n                return { data: data.map((p: any) => p.profiles), error: null };\n            });\n        } catch (err: any) {\n            return { data: [], error: err.message };\n        }\n    },\n\n    async getMessages(roomId: string, limit = 50, ascending = true): Promise<{ data: MessageData[]; error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                const { data, error } = await client\n                    .from('messages')\n                    .select(`\n                        *,\n                        profiles:user_id (\n                            id, username, full_name, avatar_url, gender\n                        )\n                    `)\n                    .eq('room_id', roomId)\n                    .order('created_at', { ascending })\n                    .limit(limit);\n\n                if (error) return { data: [], error: error.message };\n                return { data: (data as MessageData[]) || [], error: null };\n            });\n        } catch (err: any) {\n            return { data: [], error: err.message };\n        }\n    },\n\n    async sendMessage(roomId: string, content: string, type: string = 'text', mediaUrl?: string): Promise<{ data: MessageData | null; error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                const { data: { user } } = await client.auth.getUser();\n                if (!user) throw new Error('Not authenticated');\n\n                // Check if anyone in the room has blocked the sender\n                const { data: participants } = await client\n                    .from('room_participants')\n                    .select('user_id')\n                    .eq('room_id', roomId)\n                    .neq('user_id', user.id);\n\n                if (participants && participants.length > 0) {\n                    const participantIds = participants.map(p => p.user_id);\n                    // Check if sender is blocked by any participant OR sender has blocked any participant\n                    const { data: blocks } = await client\n                        .from('blocked_users')\n                        .select('id')\n                        .or(`and(blocker_id.eq.${user.id},blocked_id.in.(${participantIds.join(',')})),and(blocker_id.in.(${participantIds.join(',')}),blocked_id.eq.${user.id})`)\n                        .maybeSingle();\n\n                    if (blocks) {\n                        throw new Error('Cannot send message: Blocked connection');\n                    }\n                }\n\n                const { data, error } = await client\n                    .from('messages')\n                    .insert({\n                        room_id: roomId,\n                        user_id: user.id,\n                        content,\n                        message_type: type,\n                        media_url: mediaUrl,\n                        status: 'sent'\n                    })\n                    .select()\n                    .single();\n\n                if (error) {\n                    console.error('[ChatService] sendMessage error:', error);\n                    return { data: null, error: error.message };\n                }\n\n                // Send Push Notifications asynchronously\n                (async () => {\n                    try {\n                        // Get all participants except sender\n                        const { data: recipients } = await client\n                            .from('room_participants')\n                            .select('user_id, profiles(push_token, full_name, username)')\n                            .eq('room_id', roomId)\n                            .neq('user_id', user.id);\n\n                        if (recipients) {\n                            const senderName = user.user_metadata?.username || 'Gossiper';\n                            const title = `New Gossip from ${senderName}`;\n                            const body = type === 'text' ? content : `Sent a ${type}`;\n\n                            for (const r of recipients) {\n                                const profile = r.profiles as any;\n                                if (profile && profile.push_token) {\n                                    sendPushNotification(profile.push_token, title, body, {\n                                        chatId: roomId,\n                                        senderId: user.id\n                                    });\n                                }\n                            }\n                        }\n                    } catch (pushErr) {\n                        console.error('[ChatService] Failed to send push:', pushErr);\n                    }\n                })();\n\n                return { data: data as MessageData, error: null };\n            });\n        } catch (err: any) {\n            return { data: null, error: err.message };\n        }\n    },\n\n    async deleteMessage(messageId: string): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { error } = await client\n                .from('messages')\n                .update({ is_deleted: true, content: 'deleted' })\n                .eq('id', messageId);\n            return { error: error?.message || null };\n        });\n    },\n\n    async createDirectChat(otherUserId: string): Promise<{ data: string | null; error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                const { data: { user } } = await client.auth.getUser();\n                if (!user) throw new Error('Not authenticated');\n\n                const { data: existing } = await client.rpc('get_direct_room', {\n                    user1: user.id,\n                    user2: otherUserId\n                });\n\n                if (existing) return { data: existing, error: null };\n\n                const { data: room, error: roomError } = await client\n                    .from('rooms')\n                    .insert({ type: 'direct', created_by: user.id })\n                    .select()\n                    .single();\n\n                if (roomError) return { data: null, error: roomError.message };\n\n                const participants = [\n                    { room_id: room.id, user_id: user.id, role: 'owner' },\n                    { room_id: room.id, user_id: otherUserId, role: 'member' }\n                ];\n\n                const { error: partError } = await client\n                    .from('room_participants')\n                    .insert(participants);\n\n                if (partError) return { data: null, error: partError.message };\n\n                return { data: room.id, error: null };\n            });\n        } catch (err: any) {\n            return { data: null, error: err.message };\n        }\n    },\n\n    async createGroupChat(name: string, participantIds: string[]): Promise<{ data: string | null; error: string | null }> {\n        try {\n            return await safeSupabaseOperation(async (client) => {\n                const { data: { user } } = await client.auth.getUser();\n                if (!user) throw new Error('Not authenticated');\n\n                const { data: room, error: roomError } = await client\n                    .from('rooms')\n                    .insert({ name, type: 'group', created_by: user.id })\n                    .select()\n                    .single();\n\n                if (roomError) return { data: null, error: roomError.message };\n\n                const participants = [\n                    { room_id: room.id, user_id: user.id, role: 'owner' },\n                    ...participantIds.map(id => ({ room_id: room.id, user_id: id, role: 'member' }))\n                ];\n\n                const { error: partError } = await client\n                    .from('room_participants')\n                    .insert(participants);\n\n                if (partError) return { data: null, error: partError.message };\n\n                return { data: room.id, error: null };\n            });\n        } catch (err: any) {\n            return { data: null, error: err.message };\n        }\n    },\n\n    async updateRoom(roomId: string, updates: { name?: string; description?: string; avatar_url?: string }): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { error } = await client\n                .from('rooms')\n                .update(updates)\n                .eq('id', roomId);\n            return { error: error?.message || null };\n        });\n    },\n\n    async uploadGroupAvatar(roomId: string, file: File): Promise<{ data: string | null; error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            try {\n                const fileExt = file.name.split('.').pop() || 'jpg';\n                const fileName = `group_${roomId}_${Date.now()}.${fileExt}`;\n                const filePath = `groups/${fileName}`;\n\n                const { error: uploadError } = await client.storage\n                    .from('gossip-avatars')\n                    .upload(filePath, file, {\n                        contentType: file.type,\n                        upsert: false\n                    });\n\n                if (uploadError) throw uploadError;\n\n                const { data } = client.storage\n                    .from('gossip-avatars')\n                    .getPublicUrl(filePath);\n\n                return { data: data.publicUrl, error: null };\n            } catch (err: any) {\n                return { data: null, error: err.message };\n            }\n        });\n    },\n\n    async uploadChatAttachment(roomId: string, file: File, type: 'image' | 'video' | 'audio' | 'document'): Promise<{ data: string | null; error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            try {\n                const fileExt = file.name.split('.').pop() || 'dat';\n                const folder = type === 'image' ? 'images' : type === 'video' ? 'videos' : 'docs';\n                const fileName = `${folder}/${roomId}_${Date.now()}.${fileExt}`;\n\n                const { error: uploadError } = await client.storage\n                    .from('chat-attachments')\n                    .upload(fileName, file, {\n                        contentType: file.type,\n                        upsert: false\n                    });\n\n                if (uploadError) throw uploadError;\n\n                const { data } = client.storage\n                    .from('chat-attachments')\n                    .getPublicUrl(fileName);\n\n                return { data: data.publicUrl, error: null };\n            } catch (err: any) {\n                return { data: null, error: err.message };\n            }\n        });\n    },\n\n    async updateOnlineStatus(userId: string, isOnline: boolean): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { error } = await client\n                .from('profiles')\n                .update({ is_online: isOnline, last_seen: new Date().toISOString() })\n                .eq('id', userId);\n            return { error: error?.message || null };\n        });\n    },\n\n    async getRoomParticipantsProfiles(roomId: string): Promise<{ data: any[]; error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { data, error } = await client\n                .from('room_participants')\n                .select('profiles (*)')\n                .eq('room_id', roomId);\n            if (error) return { data: [], error: error.message };\n            return { data: data.map((p: any) => p.profiles), error: null };\n        });\n    },\n\n    async sendConnectionRequest(targetUserId: string): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { error: 'Not authenticated' };\n\n            const { error } = await client\n                .from('connections')\n                .insert({\n                    requester_id: user.id,\n                    addressee_id: targetUserId,\n                    status: 'pending'\n                });\n\n            return { error: error?.message || null };\n        });\n    },\n\n    async getPendingRequests(): Promise<{ data: any[]; error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { data: [], error: 'Not authenticated' };\n\n            const { data, error } = await client\n                .from('connections')\n                .select(`\n                    id,\n                    requester_id,\n                    created_at,\n                    profiles:requester_id (\n                        id,\n                        username,\n                        full_name,\n                        avatar_url\n                    )\n                `)\n                .eq('addressee_id', user.id)\n                .eq('status', 'pending');\n\n            if (error) return { data: [], error: error.message };\n            return { data: data || [], error: null };\n        });\n    },\n\n    async getAcceptedConnections(): Promise<{ data: any[]; error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { data: [], error: 'Not authenticated' };\n\n            // Get connections where I am requester OR addressee\n            const { data, error } = await client\n                .from('connections')\n                .select(`\n                    id,\n                    requester_id,\n                    addressee_id,\n                    status,\n                    created_at,\n                    requester:requester_id (id, username, full_name, avatar_url, is_online, last_seen, gender, age),\n                    addressee:addressee_id (id, username, full_name, avatar_url, is_online, last_seen, gender, age)\n                `)\n                .or(`requester_id.eq.${user.id},addressee_id.eq.${user.id}`)\n                .eq('status', 'accepted');\n\n            if (error) return { data: [], error: error.message };\n\n            // Transform to just return the OTHER user's profile\n            const connections = data.map((conn: any) => {\n                const isRequester = conn.requester_id === user.id;\n                const profile = isRequester ? conn.addressee : conn.requester;\n                return {\n                    connection_id: conn.id,\n                    ...profile\n                };\n            });\n\n            return { data: connections, error: null };\n        });\n    },\n\n    async respondToConnection(connectionId: string, status: 'accepted' | 'rejected'): Promise<{ data: string | null; error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { error } = await client\n                .from('connections')\n                .update({ status })\n                .eq('id', connectionId);\n\n            if (error) return { data: null, error: error.message };\n\n            let roomId = null;\n            // If accepted, create a direct chat room\n            if (status === 'accepted') {\n                const { data: connection } = await client\n                    .from('connections')\n                    .select('requester_id, addressee_id')\n                    .eq('id', connectionId)\n                    .single();\n\n                if (connection) {\n                    const { data: id, error: chatError } = await this.createDirectChat(connection.requester_id);\n                    if (chatError) return { data: null, error: chatError };\n                    roomId = id;\n                }\n            }\n\n            return { data: roomId, error: null };\n        });\n    },\n\n    async deleteRoom(roomId: string): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { error } = await client.from('rooms').delete().eq('id', roomId);\n            return { error: error?.message || null };\n        });\n    },\n\n    async updateMessageStatus(messageId: string, status: 'delivered' | 'read'): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const updateObj: any = { status };\n            if (status === 'delivered') updateObj.delivered_at = new Date().toISOString();\n            if (status === 'read') updateObj.read_at = new Date().toISOString();\n\n            const { error } = await client\n                .from('messages')\n                .update(updateObj)\n                .eq('id', messageId);\n            return { error: error?.message || null };\n        });\n    },\n\n    async markRoomAsRead(roomId: string, userId: string): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { error } = await client\n                .from('messages')\n                .update({ status: 'read', read_at: new Date().toISOString() })\n                .eq('room_id', roomId)\n                .neq('user_id', userId)\n                .neq('status', 'read');\n            return { error: error?.message || null };\n        });\n    },\n\n    async blockUser(targetUserId: string): Promise<{ error: string | null }> {\n        console.log('[ChatService] Blocking user:', targetUserId);\n        return await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { error: 'Not authenticated' };\n\n            const { error } = await client\n                .from('blocked_users')\n                .insert({ blocker_id: user.id, blocked_id: targetUserId });\n\n            if (error) {\n                console.error('[ChatService] blockUser error:', error);\n                return { error: error.message };\n            }\n            return { error: null };\n        });\n    },\n\n    async unblockUser(targetUserId: string): Promise<{ error: string | null }> {\n        return await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { error: 'Not authenticated' };\n\n            const { error } = await client\n                .from('blocked_users')\n                .delete()\n                .eq('blocker_id', user.id)\n                .eq('blocked_id', targetUserId);\n            return { error: error?.message || null };\n        });\n    },\n\n    async isBlocked(targetUserId: string): Promise<boolean> {\n        const { data } = await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { data: null };\n\n            return await client\n                .from('blocked_users')\n                .select('id')\n                .or(`and(blocker_id.eq.${user.id},blocked_id.eq.${targetUserId}),and(blocker_id.eq.${targetUserId},blocked_id.eq.${user.id})`)\n                .maybeSingle();\n        });\n        return !!data;\n    },\n\n    async getBlockedUsers(): Promise<{ data: any[]; error: string | null }> {\n        console.log('[ChatService] Fetching blocked users...');\n        return await safeSupabaseOperation(async (client) => {\n            const { data: { user } } = await client.auth.getUser();\n            if (!user) return { data: [], error: 'Not authenticated' };\n\n            const { data, error } = await client\n                .from('blocked_users')\n                .select(`\n                    id,\n                    blocked_id,\n                    profiles:blocked_id (*)\n                `)\n                .eq('blocker_id', user.id);\n\n            if (error) {\n                console.error('[ChatService] getBlockedUsers error:', error);\n                return { data: [], error: error.message };\n            }\n\n            const blockedUsers = (data || []).map((item: any) => ({\n                id: item.blocked_id,\n                username: item.profiles?.username || 'Unknown',\n                full_name: item.profiles?.full_name || 'Unknown Gossiper',\n                avatar_url: item.profiles?.avatar_url\n            }));\n\n            console.log(`[ChatService] Found ${blockedUsers.length} blocked users`);\n            return { data: blockedUsers, error: null };\n        });\n    }\n};\n","export const sendPushNotification = async (token: string, title: string, body: string, data?: any) => {\n    console.log('[NotificationService] Web Push Stub:', { token, title, body, data });\n    // In a real web app, you'd use the Web Push API or a service like Firebase Cloud Messaging for Web\n    return true;\n};\n\nexport const registerForPushNotificationsAsync = async () => {\n    console.log('[NotificationService] Register for Push Stub');\n    return null;\n};\n","\"use client\";\n\nimport React, { createContext, useState, ReactNode, useEffect, useRef, useContext } from 'react';\nimport { useAuth } from './auth-context';\nimport { createClient } from '@/lib/supabase/client';\nimport { ChatService, MessageData } from '@/services/chat-service';\n\nexport interface Message {\n    id: string;\n    chatId: string;\n    senderId: string;\n    content: string;\n    type: 'text' | 'image' | 'video' | 'audio' | 'document';\n    timestamp: Date;\n    status: 'sent' | 'delivered' | 'read';\n    mediaUrl?: string;\n}\n\nexport interface Chat {\n    id: string;\n    userId: string;\n    userName: string;\n    userAvatar: string;\n    lastMessage: string;\n    lastMessageTime: Date;\n    unreadCount: number;\n    online: boolean;\n    typing: boolean;\n    type: 'direct' | 'group';\n    age?: number;\n    gender?: string;\n    onlineCount?: number;\n    memberCount?: number;\n    description?: string;\n    createdBy?: string;\n}\n\nexport interface ConnectionRequest {\n    id: string;\n    requester_id: string;\n    created_at: string;\n    profiles: {\n        id: string;\n        username: string;\n        full_name: string;\n        avatar_url: string;\n    };\n}\n\ninterface ChatContextType {\n    chats: Chat[];\n    messages: Record<string, Message[]>;\n    pendingRequests: ConnectionRequest[];\n    loading: boolean;\n    sendMessage: (chatId: string, content: string, type?: string, mediaUrl?: string) => Promise<void>;\n    markAsRead: (chatId: string) => void;\n    setTyping: (chatId: string, isTyping: boolean) => void;\n    createChat: (userId: string, userName: string, userAvatar: string) => Promise<string>;\n    sendRequest: (userId: string) => Promise<void>;\n    respondToRequest: (requestId: string, status: 'accepted' | 'rejected') => Promise<string | null>;\n    refreshChats: () => Promise<void>;\n    blockUser: (userId: string) => Promise<void>;\n    unblockUser: (userId: string) => Promise<void>;\n    deleteGroup: (roomId: string) => Promise<void>;\n    fetchMessages: (chatId: string) => Promise<void>;\n    updateGroup: (roomId: string, updates: { name?: string; description?: string; avatar_url?: string }) => Promise<void>;\n    getParticipants: (roomId: string) => Promise<any[]>;\n    lockedChats: Record<string, string>; // Map chatId -> PIN\n    lockChat: (chatId: string, pin: string) => Promise<void>;\n    unlockChat: (chatId: string) => Promise<void>;\n}\n\nexport const ChatContext = createContext<ChatContextType | undefined>(undefined);\n\nexport function ChatProvider({ children }: { children: ReactNode }) {\n    const { user } = useAuth();\n    const [chats, setChats] = useState<Chat[]>([]);\n    const [messages, setMessages] = useState<Record<string, Message[]>>({});\n    const [pendingRequests, setPendingRequests] = useState<ConnectionRequest[]>([]);\n    const [lockedChats, setLockedChats] = useState<Record<string, string>>({});\n    const [loading, setLoading] = useState(false);\n    const supabase = createClient();\n    const channelRef = useRef<any>(null);\n    const isFetchingRef = useRef(false);\n    const hasInitialLoaded = useRef(false);\n\n    useEffect(() => {\n        if (user?.id) {\n            if (!hasInitialLoaded.current) {\n                setLoading(true);\n                loadInitialData().finally(() => {\n                    setLoading(false);\n                    hasInitialLoaded.current = true;\n                });\n            }\n\n            setupRealtime();\n            ChatService.updateOnlineStatus(user.id, true);\n\n            const pollInterval = setInterval(() => {\n                refreshChats();\n            }, 30000);\n\n            return () => {\n                clearInterval(pollInterval);\n                ChatService.updateOnlineStatus(user.id, false);\n                cleanupRealtime();\n            };\n        } else {\n            setChats([]);\n            setMessages({});\n            setPendingRequests([]);\n            setLockedChats({});\n            setLoading(false);\n            hasInitialLoaded.current = false;\n            cleanupRealtime();\n        }\n    }, [user?.id]);\n\n    useEffect(() => {\n        const stored = localStorage.getItem('LOCKED_CHATS');\n        if (stored) setLockedChats(JSON.parse(stored));\n    }, []);\n\n    const cleanupRealtime = () => {\n        if (channelRef.current) {\n            supabase.removeChannel(channelRef.current);\n            channelRef.current = null;\n        }\n    };\n\n    const loadInitialData = async () => {\n        if (isFetchingRef.current) return;\n        isFetchingRef.current = true;\n        try {\n            const [roomsResponse, requestsResponse, connectionsResponse] = await Promise.all([\n                ChatService.getMyRooms(),\n                ChatService.getPendingRequests(),\n                ChatService.getAcceptedConnections()\n            ]);\n\n            if (requestsResponse.data) {\n                setPendingRequests(requestsResponse.data);\n            }\n\n            const formattedChats: Chat[] = [];\n            const existingUserIds = new Set<string>();\n\n            if (roomsResponse.data) {\n                const chatPromises = roomsResponse.data.map(room => formatRoomToChat(room));\n                const results = await Promise.all(chatPromises);\n                results.forEach(chat => {\n                    if (chat) {\n                        formattedChats.push(chat);\n                        if (chat.type === 'direct') existingUserIds.add(chat.userId);\n                    }\n                });\n            }\n\n            if (connectionsResponse.data) {\n                connectionsResponse.data.forEach((conn: any) => {\n                    if (!existingUserIds.has(conn.id)) {\n                        formattedChats.push({\n                            id: `temp_${conn.id}`,\n                            userId: conn.id,\n                            userName: conn.username || conn.full_name || 'User',\n                            userAvatar: conn.avatar_url || `https://i.pravatar.cc/150?u=${conn.id}`,\n                            lastMessage: 'Tap to start chatting',\n                            lastMessageTime: new Date(conn.created_at || Date.now()),\n                            unreadCount: 0,\n                            online: conn.is_online || false,\n                            typing: false,\n                            type: 'direct',\n                            age: conn.age,\n                            gender: conn.gender,\n                        });\n                    }\n                });\n            }\n\n            setChats(prev => {\n                const sorted = [...formattedChats].sort((a, b) => b.lastMessageTime.getTime() - a.lastMessageTime.getTime());\n                if (JSON.stringify(prev) === JSON.stringify(sorted)) return prev;\n                return sorted;\n            });\n        } catch (error) {\n            console.error('[ChatContext] Load error:', error);\n        } finally {\n            isFetchingRef.current = false;\n        }\n    };\n\n    const formatRoomToChat = async (room: any): Promise<Chat | null> => {\n        const participants = await ChatService.getRoomParticipants(room.id);\n        const { data: msgs } = await ChatService.getMessages(room.id, 1, false);\n        const lastMsg = msgs?.[0];\n\n        if (room.type === 'direct') {\n            const otherUser = participants.data?.find(p => p.id !== user?.id);\n            if (otherUser) {\n                const { count } = await supabase\n                    .from('messages')\n                    .select('*', { count: 'exact', head: true })\n                    .eq('room_id', room.id)\n                    .neq('user_id', user?.id)\n                    .neq('status', 'read');\n\n                return {\n                    id: room.id,\n                    userId: otherUser.id,\n                    userName: otherUser.username || otherUser.full_name || 'User',\n                    userAvatar: otherUser.avatar_url || `https://i.pravatar.cc/150?u=${otherUser.id}`,\n                    lastMessage: lastMsg?.content || 'Started a gossip...',\n                    lastMessageTime: lastMsg ? new Date(lastMsg.created_at) : new Date(room.created_at),\n                    unreadCount: count || 0,\n                    online: otherUser.is_online || false,\n                    typing: false,\n                    type: 'direct',\n                    age: otherUser.age,\n                    gender: otherUser.gender,\n                };\n            }\n        } else {\n            const { count } = await supabase\n                .from('messages')\n                .select('*', { count: 'exact', head: true })\n                .eq('room_id', room.id)\n                .neq('user_id', user?.id)\n                .neq('status', 'read');\n\n            const onlineCount = participants.data?.filter(p => p.is_online).length || 0;\n            const memberCount = participants.data?.length || 0;\n\n            return {\n                id: room.id,\n                userId: room.id,\n                userName: room.name || 'Gossip Group',\n                userAvatar: room.avatar_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(room.name || 'G')}&background=FFB6C1&color=000`,\n                lastMessage: lastMsg?.content || 'New gossip group created!',\n                lastMessageTime: lastMsg ? new Date(lastMsg.created_at) : new Date(room.created_at),\n                unreadCount: count || 0,\n                online: onlineCount > 0,\n                onlineCount,\n                memberCount,\n                description: room.description || 'Welcome to the gossip group!',\n                createdBy: room.created_by,\n                typing: false,\n                type: 'group',\n            };\n        }\n        return null;\n    };\n\n    const setupRealtime = () => {\n        cleanupRealtime();\n        if (!user?.id) return;\n\n        const channel = supabase\n            .channel('gossip-main', {\n                config: {\n                    broadcast: { self: false },\n                    presence: { key: user.id }\n                }\n            })\n            .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, async (payload) => {\n                const newMessage = payload.new as MessageData;\n\n                if (newMessage.user_id !== user?.id && newMessage.status === 'sent') {\n                    ChatService.updateMessageStatus(newMessage.id, 'delivered');\n                }\n\n                const formattedMsg: Message = {\n                    id: newMessage.id,\n                    chatId: newMessage.room_id,\n                    senderId: newMessage.user_id,\n                    content: newMessage.content,\n                    type: newMessage.message_type as any,\n                    timestamp: new Date(newMessage.created_at),\n                    status: newMessage.status,\n                    mediaUrl: newMessage.media_url,\n                };\n\n                setMessages(prev => {\n                    const currentMsgs = prev[newMessage.room_id] || [];\n                    if (currentMsgs.some(m => m.id === formattedMsg.id)) return prev;\n                    return { ...prev, [newMessage.room_id]: [...currentMsgs, formattedMsg] };\n                });\n\n                refreshChats();\n            })\n            .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'messages' }, (payload) => {\n                const updatedMsg = payload.new as MessageData;\n                setMessages(prev => {\n                    const roomMsgs = prev[updatedMsg.room_id] || [];\n                    return {\n                        ...prev,\n                        [updatedMsg.room_id]: roomMsgs.map(m => m.id === updatedMsg.id ? { ...m, status: updatedMsg.status } : m)\n                    };\n                });\n            })\n            .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'profiles' }, (payload) => {\n                const updatedProfile = payload.new;\n                setChats(prev => prev.map(chat => chat.userId === updatedProfile.id ? { ...chat, online: updatedProfile.is_online } : chat));\n            })\n            .on('postgres_changes', { event: '*', schema: 'public', table: 'connections', filter: `addressee_id=eq.${user.id}` }, async () => {\n                const { data: requests } = await ChatService.getPendingRequests();\n                if (requests) setPendingRequests(requests);\n            })\n            .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'room_participants', filter: `user_id=eq.${user.id}` }, () => {\n                refreshChats();\n            })\n            .on('broadcast', { event: 'typing' }, (payload) => {\n                const { chatId, userId, isTyping } = payload.payload;\n                if (userId === user?.id) return;\n                setChats(prev => prev.map(chat => chat.id === chatId ? { ...chat, typing: isTyping } : chat));\n            })\n            .subscribe();\n\n        channelRef.current = channel;\n    };\n\n    const sendMessage = async (chatId: string, content: string, type: string = 'text', mediaUrl?: string) => {\n        const { data: sentMsg, error } = await ChatService.sendMessage(chatId, content, type, mediaUrl);\n        if (error) throw new Error(error);\n\n        if (sentMsg) {\n            const formattedMsg: Message = {\n                id: sentMsg.id,\n                chatId: sentMsg.room_id,\n                senderId: sentMsg.user_id,\n                content: sentMsg.content,\n                type: sentMsg.message_type as any,\n                timestamp: new Date(sentMsg.created_at),\n                status: sentMsg.status,\n                mediaUrl: sentMsg.media_url,\n            };\n\n            setMessages(prev => {\n                const currentMsgs = prev[chatId] || [];\n                if (currentMsgs.some(m => m.id === formattedMsg.id)) return prev;\n                return { ...prev, [chatId]: [...currentMsgs, formattedMsg] };\n            });\n        }\n    };\n\n    const markAsRead = async (chatId: string) => {\n        if (!user?.id) return;\n        await ChatService.markRoomAsRead(chatId, user.id);\n        setChats(prev => prev.map(chat => chat.id === chatId ? { ...chat, unreadCount: 0 } : chat));\n        setMessages(prev => {\n            const roomMsgs = prev[chatId];\n            if (!roomMsgs) return prev;\n            return { ...prev, [chatId]: roomMsgs.map(m => m.senderId !== user.id ? { ...m, status: 'read' } : m) };\n        });\n    };\n\n    const setTyping = async (chatId: string, isTyping: boolean) => {\n        if (channelRef.current) {\n            await channelRef.current.send({\n                type: 'broadcast',\n                event: 'typing',\n                payload: { chatId, userId: user?.id, isTyping },\n            });\n        }\n    };\n\n    const createChat = async (userId: string, userName: string, userAvatar: string): Promise<string> => {\n        const { data: roomId, error } = await ChatService.createDirectChat(userId);\n        if (error) throw new Error(error);\n        await loadInitialData();\n        return roomId!;\n    };\n\n    const sendRequest = async (userId: string) => {\n        const { error } = await ChatService.sendConnectionRequest(userId);\n        if (error) throw new Error(error);\n    };\n\n    const respondToRequest = async (requestId: string, status: 'accepted' | 'rejected'): Promise<string | null> => {\n        setLoading(true);\n        const { data: roomId, error } = await ChatService.respondToConnection(requestId, status);\n        if (error) {\n            setLoading(false);\n            return null;\n        }\n        setPendingRequests(prev => prev.filter(r => r.id !== requestId));\n        await loadInitialData();\n        setLoading(false);\n        return roomId;\n    };\n\n    const fetchMessages = async (chatId: string) => {\n        const { data, error } = await ChatService.getMessages(chatId);\n        if (!error && data) {\n            const formattedMsgs: Message[] = data.map(m => ({\n                id: m.id,\n                chatId: m.room_id,\n                senderId: m.user_id,\n                content: m.content,\n                type: m.message_type as any,\n                timestamp: new Date(m.created_at),\n                status: m.status,\n                mediaUrl: m.media_url,\n            }));\n            setMessages(prev => ({ ...prev, [chatId]: formattedMsgs }));\n        }\n    };\n\n    const refreshChats = async () => {\n        await loadInitialData();\n    };\n\n    const blockUser = async (userId: string) => {\n        const { error } = await ChatService.blockUser(userId);\n        if (error) throw new Error(error);\n        await refreshChats();\n    };\n\n    const unblockUser = async (userId: string) => {\n        const { error } = await ChatService.unblockUser(userId);\n        if (error) throw new Error(error);\n        await refreshChats();\n    };\n\n    const deleteGroup = async (roomId: string) => {\n        const { error } = await ChatService.deleteRoom(roomId);\n        if (error) throw new Error(error);\n        await refreshChats();\n    };\n\n    const updateGroup = async (roomId: string, updates: { name?: string; description?: string; avatar_url?: string }) => {\n        const { error } = await ChatService.updateRoom(roomId, updates);\n        if (error) throw new Error(error);\n        await refreshChats();\n    };\n\n    const getParticipants = async (roomId: string) => {\n        const { data, error } = await ChatService.getRoomParticipantsProfiles(roomId);\n        if (error) throw new Error(error);\n        return data || [];\n    };\n\n    const lockChat = async (chatId: string, pin: string) => {\n        const updated = { ...lockedChats, [chatId]: pin };\n        setLockedChats(updated);\n        localStorage.setItem('LOCKED_CHATS', JSON.stringify(updated));\n    };\n\n    const unlockChat = async (chatId: string) => {\n        const updated = { ...lockedChats };\n        delete updated[chatId];\n        setLockedChats(updated);\n        localStorage.setItem('LOCKED_CHATS', JSON.stringify(updated));\n    };\n\n    return (\n        <ChatContext.Provider value={{\n            chats, messages, pendingRequests, loading, sendMessage, markAsRead, setTyping, createChat, sendRequest, respondToRequest, refreshChats, blockUser, unblockUser, deleteGroup, fetchMessages, updateGroup, getParticipants,\n            lockedChats, lockChat, unlockChat\n        }}>\n            {children}\n        </ChatContext.Provider>\n    );\n}\n\nexport function useChat() {\n    const context = useContext(ChatContext);\n    if (!context) throw new Error('useChat must be used within ChatProvider');\n    return context;\n}\n"],"names":[],"mappings":"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"}